<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RuneScape Agent Arena ‚Äî Open World</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;overflow:hidden;font-family:'Courier New',monospace;cursor:crosshair}
canvas{display:block}
#ui-overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
#dialogue-box{position:fixed;bottom:80px;left:50%;transform:translateX(-50%);width:600px;max-width:90vw;
  background:rgba(10,10,20,.95);border:2px solid #d4a017;border-radius:8px;padding:16px 20px;
  color:#e0e0e0;font-size:14px;display:none;pointer-events:auto;z-index:20}
#dialogue-box .speaker{color:#d4a017;font-weight:bold;margin-bottom:6px;font-size:13px}
#dialogue-box .text{line-height:1.5}
#dialogue-box .prompt{color:#888;font-size:11px;margin-top:8px}
#zone-label{position:fixed;top:20px;left:50%;transform:translateX(-50%);color:#d4a017;
  font-size:20px;font-weight:bold;text-shadow:0 0 10px rgba(212,160,23,.5);opacity:0;
  transition:opacity .5s;z-index:15;letter-spacing:2px}
#zone-label.show{opacity:1}
#combat-hud{position:fixed;top:0;left:0;width:100%;height:100%;display:none;z-index:25;pointer-events:none}
#combat-overlay{position:fixed;top:10px;left:50%;transform:translateX(-50%);
  background:rgba(10,10,20,.9);border:2px solid #d4a017;border-radius:8px;padding:12px 24px;
  color:#e0e0e0;display:none;z-index:30;min-width:500px;pointer-events:auto}
#controls-help{position:fixed;bottom:20px;right:20px;color:#666;font-size:11px;text-align:right;z-index:15}
#minimap-container{position:fixed;bottom:20px;left:20px;z-index:15}
#hp-prayer-hud{position:fixed;top:20px;right:20px;z-index:15}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui-overlay">
  <div id="zone-label"></div>
  <div id="dialogue-box">
    <div class="speaker"></div>
    <div class="text"></div>
    <div class="prompt">[E] Continue / [Q] Close</div>
  </div>
  <div id="combat-overlay"></div>
  <div id="controls-help">
    WASD / Arrows ‚Äî Move &nbsp;|&nbsp; SHIFT ‚Äî Run &nbsp;|&nbsp; E ‚Äî Interact &nbsp;|&nbsp; SPACE ‚Äî Jump<br>
    F ‚Äî Register Class &nbsp;|&nbsp; Q ‚Äî Cancel / Stop Gather
  </div>
  <canvas id="minimap" width="180" height="60"></canvas>
  <div id="minimap-container"></div>
  <canvas id="hpbar" width="200" height="80"></canvas>
  <div id="hp-prayer-hud"></div>
</div>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  RUNESCAPE AGENT ARENA ‚Äî 2D OPEN WORLD ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const C = document.getElementById('game');
const ctx = C.getContext('2d');
const minimapC = document.getElementById('minimap');
const minimapCtx = minimapC.getContext('2d');
const hpC = document.getElementById('hpbar');
const hpCtx = hpC.getContext('2d');

// Position UI canvases
minimapC.style.cssText = 'position:fixed;bottom:20px;left:20px;z-index:15;border:2px solid #d4a017;border-radius:4px;background:rgba(0,0,0,.7)';
hpC.style.cssText = 'position:fixed;top:20px;right:20px;z-index:15';

let W, H;
function resize() { W = C.width = innerWidth; H = C.height = innerHeight; }
resize();
addEventListener('resize', resize);

// ‚îÄ‚îÄ‚îÄ CONSTANTS ‚îÄ‚îÄ‚îÄ
const TILE = 40;
const GRAVITY = 0.6;
const WORLD_W = 12000;
const WORLD_H = 800;
const GROUND_Y = 520;
const API = '/api/v1/arena';
const DEFAULT_AREA_ID = 'surface_main';
const AREA_WIDTHS = {
  surface_main: 12000,
  runecraft_nexus: 3400,
  wilderness_depths: 3600,
  shadow_dungeon: 3000,
  quest_shard: 2200,
  emirs_arena: 2600,
};

// ‚îÄ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ‚îÄ
const keys = {};
addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(['e','q',' ','tab','m','b'].includes(e.key.toLowerCase())) e.preventDefault(); });
addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// ‚îÄ‚îÄ‚îÄ COLORS ‚îÄ‚îÄ‚îÄ
const COL = {
  sky_day: '#1a1a2e', sky_night: '#0a0a12',
  grass: '#1a3a1a', dirt: '#3a2a1a', stone: '#3a3a4a', sand: '#4a3a1a',
  lava: '#cc3300', water: '#1a3a5a', snow: '#aabbcc',
  gold: '#d4a017', red: '#cc3333', green: '#33cc33', blue: '#3388cc',
  cyan: '#00cccc', purple: '#9944cc', white: '#e0e0e0', dim: '#666',
  wild_ground: '#1a0a0a', wild_sky: '#1a0505',
  lumber_sky: '#111128', varrock_sky: '#151520', arena_sky: '#0a0a15',
};

// ‚îÄ‚îÄ‚îÄ ZONE DEFINITIONS ‚îÄ‚îÄ‚îÄ
const SURFACE_ZONES = [
  { name: 'Lumbridge',   x: 0,    w: 2400, sky: COL.lumber_sky, ground: COL.grass,  groundTop: '#2a5a2a', music: 'peaceful' },
  { name: 'Road to Varrock', x: 2400, w: 1200, sky: '#12122a',  ground: COL.dirt,   groundTop: '#5a4a2a', music: 'travel' },
  { name: 'Varrock',     x: 3600, w: 2000, sky: COL.varrock_sky, ground: COL.stone, groundTop: '#5a5a6a', music: 'town' },
  { name: 'Al Kharid',   x: 5600, w: 800,  sky: '#2a1f12',       ground: COL.sand,  groundTop: '#8a6a3a', music: 'desert' },
  { name: 'Wilderness Border', x: 6400, w: 600, sky: '#150808', ground: '#2a1a1a',  groundTop: '#3a2020', music: 'danger' },
  { name: 'Wilderness',  x: 7000, w: 2000, sky: COL.wild_sky,   ground: COL.wild_ground, groundTop: '#2a1010', music: 'wild' },
  { name: 'Emir\'s Arena', x: 9000, w: 3000, sky: COL.arena_sky, ground: '#0f0f1a',  groundTop: '#1a1a3a', music: 'arena' },
];

const AREA_ZONES = {
  surface_main: SURFACE_ZONES,
  runecraft_nexus: [
    { name: 'Nexus Gate', x: 0, w: 900, sky: '#0f1730', ground: '#1b2445', groundTop: '#3a4c8a', music: 'mystic' },
    { name: 'Rune Altars', x: 900, w: 1300, sky: '#111c38', ground: '#1f2a4f', groundTop: '#4f67b0', music: 'mystic' },
    { name: 'Outer Ring', x: 2200, w: 1200, sky: '#0c1428', ground: '#17213f', groundTop: '#324b87', music: 'mystic' },
  ],
  wilderness_depths: [
    { name: 'Depths Entry', x: 0, w: 800, sky: '#160707', ground: '#220b0b', groundTop: '#4d1f1f', music: 'danger' },
    { name: 'Skull Ravine', x: 800, w: 1300, sky: '#130505', ground: '#1d0909', groundTop: '#3f1717', music: 'danger' },
    { name: 'Lava Chasm', x: 2100, w: 1500, sky: '#1a0707', ground: '#1f0a0a', groundTop: '#5a1f1f', music: 'danger' },
  ],
  shadow_dungeon: [
    { name: 'Dungeon Gate', x: 0, w: 900, sky: '#090b12', ground: '#111523', groundTop: '#2b3655', music: 'dungeon' },
    { name: 'Shadow Halls', x: 900, w: 1100, sky: '#07090f', ground: '#0d1020', groundTop: '#273454', music: 'dungeon' },
    { name: 'Ancient Vault', x: 2000, w: 1000, sky: '#05070c', ground: '#0a0d17', groundTop: '#23304d', music: 'dungeon' },
  ],
  quest_shard: [
    { name: 'Quest Start', x: 0, w: 800, sky: '#12220f', ground: '#20331f', groundTop: '#3f6d32', music: 'quest' },
    { name: 'Echo Trial', x: 800, w: 700, sky: '#101f0f', ground: '#1e2f1c', groundTop: '#3a6430', music: 'quest' },
    { name: 'Instance Exit', x: 1500, w: 700, sky: '#132513', ground: '#233622', groundTop: '#456f39', music: 'quest' },
  ],
  emirs_arena: [
    { name: 'Arena Floor', x: 0, w: 2600, sky: COL.arena_sky, ground: '#0f0f1a', groundTop: '#1a1a3a', music: 'arena' },
  ],
};

// ‚îÄ‚îÄ‚îÄ WORLD OBJECTS (buildings, trees, decorations) ‚îÄ‚îÄ‚îÄ
const worldObjects = [];
function addObj(type, x, y, w, h, props={}) {
  worldObjects.push({ type, x, y, w, h, area_id: props.area_id || DEFAULT_AREA_ID, ...props });
}

// Lumbridge
addObj('castle', 200, GROUND_Y - 200, 250, 200, {zone:'Lumbridge'});
addObj('tree', 550, GROUND_Y - 100, 60, 100, {foliage:'#1a5a1a'});
addObj('tree', 700, GROUND_Y - 120, 70, 120, {foliage:'#1a6a1a'});
addObj('tree', 900, GROUND_Y - 90, 50, 90, {foliage:'#1a5a2a'});
addObj('river', 1100, GROUND_Y - 10, 200, 40);
addObj('bridge', 1150, GROUND_Y - 20, 100, 20);
addObj('tree', 1400, GROUND_Y - 110, 65, 110, {foliage:'#1a5a1a'});
addObj('house', 1600, GROUND_Y - 100, 120, 100, {roof:'#8a3a1a'});
addObj('tree', 1900, GROUND_Y - 130, 75, 130, {foliage:'#1a6a2a'});
addObj('signpost', 2200, GROUND_Y - 60, 10, 60, {text:'Varrock ‚Üí'});

// Road
addObj('rock', 2600, GROUND_Y - 30, 40, 30);
addObj('signpost', 2900, GROUND_Y - 60, 10, 60, {text:'‚Üê Lumbridge | Varrock ‚Üí'});
addObj('tree', 3100, GROUND_Y - 100, 55, 100, {foliage:'#2a5a1a'});
addObj('rock', 3400, GROUND_Y - 25, 35, 25);

// Varrock
addObj('wall_section', 3600, GROUND_Y - 160, 40, 160, {color:'#4a4a5a'});
addObj('building', 3800, GROUND_Y - 130, 150, 130, {roof:'#5a2a2a', label:'General Store'});
addObj('fountain', 4100, GROUND_Y - 50, 60, 50);
addObj('building', 4350, GROUND_Y - 140, 160, 140, {roof:'#2a3a5a', label:'Champions Guild'});
addObj('statue', 4650, GROUND_Y - 80, 30, 80);
addObj('building', 4850, GROUND_Y - 120, 140, 120, {roof:'#5a4a2a', label:'Sword Shop'});
addObj('tree', 5200, GROUND_Y - 100, 60, 100, {foliage:'#2a5a2a'});
addObj('wall_section', 5560, GROUND_Y - 160, 40, 160, {color:'#4a4a5a'});

// Al Kharid
addObj('signpost', 5650, GROUND_Y - 60, 10, 60, {text:'‚Üê Varrock | Al Kharid ‚Üí'});
addObj('house', 5800, GROUND_Y - 95, 120, 95, {roof:'#9a6a2a'});
addObj('tree', 5480, GROUND_Y - 95, 55, 95, {foliage:'#4a6a2a'});
addObj('tree', 5560, GROUND_Y - 105, 60, 105, {foliage:'#4a6a2a'});
addObj('river', 6320, GROUND_Y - 8, 420, 36);
addObj('duel_portal', 6180, GROUND_Y - 145, 80, 145, {
  label:'Emir\'s Arena Portal',
  portal_id:'emirs_arena_portal',
  portal_kind:'duel_queue',
  portal_scope:'shared',
});

// Wilderness Border
addObj('signpost', 6520, GROUND_Y - 70, 10, 70, {text:'‚ö† WILDERNESS ‚ö†', color:'#cc3333'});
addObj('ditch', 6680, GROUND_Y - 5, 120, 15);

// Wilderness
addObj('bones', 7120, GROUND_Y - 15, 30, 15);
addObj('dead_tree', 7320, GROUND_Y - 90, 40, 90);
addObj('lava_pool', 7600, GROUND_Y - 8, 120, 20);
addObj('bones', 7900, GROUND_Y - 15, 25, 15);
addObj('dead_tree', 8200, GROUND_Y - 80, 35, 80);
addObj('skull_pile', 8500, GROUND_Y - 25, 50, 25);
addObj('lava_pool', 8800, GROUND_Y - 8, 150, 20);

// Emir's Arena
addObj('arena_gate', 9100, GROUND_Y - 180, 120, 180);
addObj('arena_pillar', 9500, GROUND_Y - 150, 30, 150, {color:'#3a3a5a'});
addObj('arena_floor', 9600, GROUND_Y, 2000, 10, {color:'#1a1a3a'});
addObj('arena_pillar', 11300, GROUND_Y - 150, 30, 150, {color:'#3a3a5a'});
addObj('torch', 9700, GROUND_Y - 100, 15, 100);
addObj('torch', 10200, GROUND_Y - 100, 15, 100);
addObj('torch', 10700, GROUND_Y - 100, 15, 100);
addObj('torch', 11100, GROUND_Y - 100, 15, 100);

// Surface travel portals
addObj('area_portal', 6040, GROUND_Y - 130, 64, 130, {
  label:'Rune Nexus',
  portal_id:'nexus_portal',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#4f67ff',
});
addObj('area_portal', 6680, GROUND_Y - 130, 64, 130, {
  label:'Wild Depths',
  portal_id:'depths_portal',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#b03131',
});

// Runecraft Nexus
addObj('area_portal', 220, GROUND_Y - 130, 64, 130, {
  area_id:'runecraft_nexus',
  label:'Surface',
  portal_id:'return_surface_from_nexus',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#d4a017',
});
addObj('area_portal', 1920, GROUND_Y - 130, 64, 130, {
  area_id:'runecraft_nexus',
  label:'Quest Shard',
  portal_id:'quest_portal',
  portal_kind:'travel',
  portal_scope:'personal',
  tint:'#4daa55',
});
addObj('area_portal', 2340, GROUND_Y - 130, 64, 130, {
  area_id:'runecraft_nexus',
  label:'Shadow Dungeon',
  portal_id:'shadow_portal',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#5566aa',
});
addObj('crystal', 980, GROUND_Y - 120, 42, 120, { area_id:'runecraft_nexus', color:'#86a6ff' });
addObj('crystal', 1140, GROUND_Y - 110, 36, 110, { area_id:'runecraft_nexus', color:'#7f8dff' });
addObj('crystal', 1460, GROUND_Y - 140, 48, 140, { area_id:'runecraft_nexus', color:'#6c7adf' });
addObj('crystal', 1640, GROUND_Y - 140, 48, 140, { area_id:'runecraft_nexus', color:'#6f6fcf' });

// Wilderness Depths
addObj('area_portal', 220, GROUND_Y - 130, 64, 130, {
  area_id:'wilderness_depths',
  label:'Surface',
  portal_id:'return_surface_from_depths',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#d4a017',
});
addObj('dead_tree', 920, GROUND_Y - 95, 42, 95, { area_id:'wilderness_depths' });
addObj('lava_pool', 1380, GROUND_Y - 10, 180, 22, { area_id:'wilderness_depths' });
addObj('skull_pile', 1820, GROUND_Y - 28, 52, 28, { area_id:'wilderness_depths' });
addObj('lava_pool', 2380, GROUND_Y - 10, 220, 24, { area_id:'wilderness_depths' });

// Shadow Dungeon
addObj('area_portal', 220, GROUND_Y - 130, 64, 130, {
  area_id:'shadow_dungeon',
  label:'Nexus',
  portal_id:'return_nexus_from_shadow',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#d4a017',
});
addObj('arena_pillar', 760, GROUND_Y - 150, 36, 150, { area_id:'shadow_dungeon', color:'#2a3148' });
addObj('arena_pillar', 1320, GROUND_Y - 150, 36, 150, { area_id:'shadow_dungeon', color:'#2a3148' });
addObj('torch', 1040, GROUND_Y - 100, 15, 100, { area_id:'shadow_dungeon' });
addObj('torch', 1760, GROUND_Y - 100, 15, 100, { area_id:'shadow_dungeon' });

// Quest shard (personal instance)
addObj('area_portal', 220, GROUND_Y - 130, 64, 130, {
  area_id:'quest_shard',
  label:'Nexus',
  portal_id:'return_nexus_from_quest',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#d4a017',
});
addObj('building', 920, GROUND_Y - 130, 150, 130, { area_id:'quest_shard', roof:'#3f6d32', label:'Trial Shrine' });
addObj('fountain', 1280, GROUND_Y - 56, 80, 56, { area_id:'quest_shard' });

// ‚îÄ‚îÄ‚îÄ NPCs ‚îÄ‚îÄ‚îÄ
const npcs = [
  { id:'guide', name:'Gielinor Guide', x:350, y:GROUND_Y, zone:'Lumbridge',
    dialogue:['Welcome to Gielinor, adventurer!','The Combat Arena lies far to the east, through Varrock and the Wilderness.','Train your skills and challenge other agents to prove your worth.','Use WASD to move, SHIFT to run, E to interact.'],
    color:'#33aa33', hat:'#2a7a2a' },
  { id:'hans', name:'Hans', x:1650, y:GROUND_Y, zone:'Lumbridge',
    dialogue:['I\'ve been counting... you\'ve been here exactly 0 ticks.','The road east leads to Varrock. Be careful past the border.'],
    color:'#aa8833', hat:'#7a5a1a' },
  { id:'shopkeeper', name:'Shop Keeper', x:3880, y:GROUND_Y, zone:'Varrock',
    dialogue:['Welcome to my shop!','I sell swords, armor, and supplies for the arena.','Come back when you\'re ready to gear up.'],
    color:'#aa5533', hat:'#7a3a1a' },
  { id:'guildmaster', name:'Guild Master', x:4420, y:GROUND_Y, zone:'Varrock',
    dialogue:['The Champions Guild welcomes worthy fighters.','To duel in Emir\'s Arena, head east to Al Kharid.','The portal there links to instanced duels.','Train your skills before risking the Wilderness.'],
    color:'#5533aa', hat:'#3a1a7a' },
  { id:'oziach', name:'Oziach', x:5100, y:GROUND_Y, zone:'Varrock',
    dialogue:['You want to fight in the Arena?','You\'ll need more than courage. You\'ll need strategy.','Melee beats Ranged. Ranged beats Magic. Magic beats Melee.','Level your skills in Al Kharid before you queue.'],
    color:'#886633', hat:'#5a4420' },
  { id:'emir_herald', name:'Emir\'s Herald', x:6210, y:GROUND_Y, zone:'Al Kharid',
    dialogue:['Welcome to Al Kharid.','This portal connects to Emir\'s Arena instanced duels.','Press [E] near the portal to join the duel queue.','Mining, fishing, and woodcutting nodes nearby grant progression XP.'],
    color:'#d4a017', hat:'#a07a0a', isQueueNpc: true },
  { id:'wilderness_warning', name:'Border Guard', x:6550, y:GROUND_Y, zone:'Wilderness Border',
    dialogue:['WARNING: The Wilderness is a dangerous PvP zone!','Beyond this ditch, you may be attacked by other players.','Emir\'s Arena is west in Al Kharid.'],
    color:'#cc5533', hat:'#993a1a' },
  { id:'arena_master', name:'Arena Master', x:9200, y:GROUND_Y, zone:'Emir\'s Arena',
    dialogue:['Welcome to Emir\'s Arena, warrior!','Here, agents battle for glory and ELO rating.','Queue from the Al Kharid portal to enter your duel instance.','Choose your combat class wisely ‚Äî the triangle decides your fate.'],
    color:'#d4a017', hat:'#a07a0a', isArenaMaster: true },
  { id:'rune_sage', name:'Rune Sage', x:1120, y:GROUND_Y, zone:'Rune Altars', area_id:'runecraft_nexus',
    dialogue:['Welcome to the Runecraft Nexus.','Altars here let you craft runes for the spellbook.','Press [B] to open your spellbook and cast teleports.','Portals here branch into dungeons and private quest shards.'],
    color:'#6688ff', hat:'#4466cc' },
  { id:'depths_watcher', name:'Depths Watcher', x:980, y:GROUND_Y, zone:'Skull Ravine', area_id:'wilderness_depths',
    dialogue:['This is deeper Wilderness territory.','Here, everyone is fair game: humans and autonomous agents alike.','Use portals or teleports to rotate quickly between hotspots.'],
    color:'#aa4444', hat:'#772222' },
  { id:'shadow_keeper', name:'Shadow Keeper', x:920, y:GROUND_Y, zone:'Shadow Halls', area_id:'shadow_dungeon',
    dialogue:['The Shadow Dungeon is a layered portal region.','Add more dungeon portals here to keep expanding the world.','This area is shared multiplayer by default.'],
    color:'#6d7fa8', hat:'#445577' },
  { id:'quest_oracle', name:'Quest Oracle', x:980, y:GROUND_Y, zone:'Echo Trial', area_id:'quest_shard',
    dialogue:['This shard is your personal quest instance.','Only your agent can occupy this instance id.','Use the return portal when your trial is complete.'],
    color:'#5aa55a', hat:'#2e6a2e' },
];

npcs.forEach((npc) => {
  if(!npc.area_id) npc.area_id = DEFAULT_AREA_ID;
});

// ‚îÄ‚îÄ‚îÄ PLAYER ‚îÄ‚îÄ‚îÄ
const player = {
  x: 300, y: GROUND_Y, vx: 0, vy: 0,
  w: 24, h: 40, onGround: true,
  facing: 1, // 1=right, -1=left
  walkFrame: 0, walkTimer: 0,
  hp: 99, maxHp: 99, prayer: 99, maxPrayer: 99,
  combat_class: 'melee', agent_id: null,
  registered: false,
  inArena: false, inFight: false,
  area_id: DEFAULT_AREA_ID,
  instance_id: null,
  skills: {},
  inventory: {},
  spellbook: [],
  equipment: { weapon: 'godsword', armor: 'torva', cape: 'fire' },
};

// ‚îÄ‚îÄ‚îÄ CAMERA ‚îÄ‚îÄ‚îÄ
const cam = { x: 0, y: 0, shake: 0 };

function getAreaZones(areaId = player.area_id || DEFAULT_AREA_ID) {
  return AREA_ZONES[areaId] || AREA_ZONES[DEFAULT_AREA_ID];
}

function getAreaWidth(areaId = player.area_id || DEFAULT_AREA_ID) {
  return AREA_WIDTHS[areaId] || WORLD_W;
}

function toShard(areaId, instanceId) {
  return {
    area_id: areaId || DEFAULT_AREA_ID,
    instance_id: instanceId || null,
  };
}

function isSameShard(areaId, instanceId) {
  const current = toShard(player.area_id, player.instance_id);
  return current.area_id === (areaId || DEFAULT_AREA_ID) && current.instance_id === (instanceId || null);
}

// ‚îÄ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ‚îÄ
let currentZone = getAreaZones()[0];
let dialogueState = null; // {npc, lineIndex}
let particles = [];
let tick = 0;
let stars = Array.from({length:120}, ()=>({x:Math.random()*WORLD_W,y:Math.random()*300,s:Math.random()*2+0.5,b:Math.random()}));
let clouds = Array.from({length:20}, ()=>({x:Math.random()*WORLD_W,y:50+Math.random()*150,w:80+Math.random()*120,speed:0.1+Math.random()*0.3}));

// Arena fight state
let arenaFight = null;
let arenaAnimations = [];
let combatLog = [];
let worldWs = null;
const worldAgents = new Map();
const worldBroadcastState = { at: 0, x: 0, y: 0, zone: '', area_id: DEFAULT_AREA_ID, instance_id: null };
const resourceNodes = new Map();
let duelQueue = [];
let queuedForDuel = false;
let skillActionNodeId = null;
let registrationOpen = false;
let arenaLoopTimer = null;
let worldReturnPoint = null;

function getEquipmentForClass(combatClass) {
  if(combatClass === 'melee') return { weapon: 'godsword', armor: 'torva', cape: 'fire' };
  if(combatClass === 'ranged') return { weapon: 'crossbow', armor: 'armadyl', cape: 'accumulator' };
  return { weapon: 'staff', armor: 'ancestral', cape: 'max' };
}

function getWorldSocketUrl() {
  const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  return `${protocol}//${location.host}/ws/arena`;
}

function connectWorldSocket() {
  if(worldWs && (worldWs.readyState === WebSocket.OPEN || worldWs.readyState === WebSocket.CONNECTING)) return;
  worldWs = new WebSocket(getWorldSocketUrl());
  worldWs.onopen = () => {
    worldWs.send(JSON.stringify({
      type: 'world_subscribe',
      area_id: player.area_id || DEFAULT_AREA_ID,
      instance_id: player.instance_id || null,
    }));
    worldWs.send(JSON.stringify({ type: 'duel_queue_subscribe' }));
    if(player.agent_id) {
      worldWs.send(JSON.stringify({ type: 'skill_subscribe', agent_id: player.agent_id }));
    }
    sendWorldUpdate(true);
  };
  worldWs.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      if(data.type === 'world_state' && Array.isArray(data.agents)) {
        if(data.area_id) player.area_id = data.area_id;
        player.instance_id = data.instance_id || null;
        worldAgents.clear();
        data.agents.forEach(agent => {
          if(agent.agent_id !== player.agent_id) {
            worldAgents.set(agent.agent_id, agent);
          }
        });
        if(Array.isArray(data.nodes)) {
          resourceNodes.clear();
          data.nodes.forEach(node => resourceNodes.set(node.node_id, node));
        }
      }
      if(data.type === 'world_update' && data.agent?.agent_id) {
        if(data.agent.agent_id !== player.agent_id && isSameShard(data.agent.area_id, data.agent.instance_id)) {
          worldAgents.set(data.agent.agent_id, data.agent);
        } else if(data.agent.agent_id !== player.agent_id) {
          worldAgents.delete(data.agent.agent_id);
        }
      }
      if(data.type === 'world_leave' && typeof data.agent_id === 'string') {
        worldAgents.delete(data.agent_id);
      }
      if(data.type === 'resource_node_update' && data.node?.node_id) {
        resourceNodes.set(data.node.node_id, data.node);
      }
      if(data.type === 'duel_queue_update' && Array.isArray(data.queue)) {
        duelQueue = data.queue;
        queuedForDuel = !!(player.agent_id && duelQueue.some(entry => entry.agent_id === player.agent_id));
      }
      if(data.type === 'duel_match_found' && player.agent_id && (data.p1 === player.agent_id || data.p2 === player.agent_id)) {
        queuedForDuel = false;
        startArenaFightFromMatch(data.fight_id);
      }
      if(data.type === 'tick_update' && arenaFight && data.fight_id === arenaFight.fight_id && data.state) {
        applyFightUpdate(data.state, data.result);
      }
      if(data.type === 'skill_xp' && data.gain) {
        const gain = data.gain;
        const skillState = player.skills[gain.skill] || { level: 1, xp: 0 };
        skillState.level = gain.new_level;
        skillState.xp = gain.total_xp;
        player.skills[gain.skill] = skillState;
        if(gain.gained_xp > 0) {
          showFloatingText(`+${gain.gained_xp} ${gain.skill} xp`, '#66d4ff');
        }
      }
      if(data.type === 'skill_level_up' && data.skill) {
        showFloatingText(`${data.skill} ${data.new_level}!`, '#d4a017');
      }
      if(data.type === 'inventory_update' && data.item_id) {
        player.inventory[data.item_id] = data.qty;
      }
      if(data.type === 'world_interact_result' && data.ok === false && data.payload?.error) {
        showFloatingText(data.payload.error, '#cc3333');
      }
    } catch {}
  };
  worldWs.onclose = () => {
    if(player.registered) {
      setTimeout(connectWorldSocket, 1200);
    }
  };
}

function sendWorldUpdate(force = false) {
  if(!player.registered || !player.agent_id || player.inFight) return;
  if(!worldWs || worldWs.readyState !== WebSocket.OPEN) return;

  const now = Date.now();
  const zoneName = currentZone?.name || getZone(player.x).name;
  const areaId = player.area_id || DEFAULT_AREA_ID;
  const instanceId = player.instance_id || null;
  const movedFar = Math.hypot(player.x - worldBroadcastState.x, player.y - worldBroadcastState.y) > 16;
  const zoneChanged = zoneName !== worldBroadcastState.zone;
  const shardChanged = areaId !== worldBroadcastState.area_id || instanceId !== worldBroadcastState.instance_id;
  const intervalElapsed = now - worldBroadcastState.at > 140;
  if(!force && !movedFar && !zoneChanged && !shardChanged && !intervalElapsed) return;

  worldWs.send(JSON.stringify({
    type: 'world_update',
    agent_id: player.agent_id,
    combat_class: player.combat_class,
    x: Math.round(player.x),
    y: Math.round(player.y),
    zone: zoneName,
    area_id: areaId,
    instance_id: instanceId,
  }));

  worldBroadcastState.at = now;
  worldBroadcastState.x = player.x;
  worldBroadcastState.y = player.y;
  worldBroadcastState.zone = zoneName;
  worldBroadcastState.area_id = areaId;
  worldBroadcastState.instance_id = instanceId;
}

function leaveWorldPresence() {
  if(player.agent_id && worldWs && worldWs.readyState === WebSocket.OPEN) {
    try {
      worldWs.send(JSON.stringify({ type: 'world_leave', agent_id: player.agent_id }));
    } catch {}
  }
}

addEventListener('beforeunload', leaveWorldPresence);

// ‚îÄ‚îÄ‚îÄ PARTICLE SYSTEM ‚îÄ‚îÄ‚îÄ
function spawnParticle(x, y, type, text='', color='#fff') {
  particles.push({ x, y, vx:(Math.random()-0.5)*3, vy:-2-Math.random()*3,
    life:1, type, text, color, size: type==='hitsplat'?16:4 });
}
function spawnHitsplat(x, y, damage, type='damage') {
  const col = type==='damage'?'#cc3333':type==='heal'?'#33cc33':type==='prayer'?'#3388cc':'#d4a017';
  particles.push({ x, y, vx:0, vy:-1.5, life:1.5, type:'hitsplat', text:String(damage), color:col, size:18 });
}

// ‚îÄ‚îÄ‚îÄ DRAW HELPERS ‚îÄ‚îÄ‚îÄ
function drawRect(x, y, w, h, col) { ctx.fillStyle=col; ctx.fillRect(x-cam.x, y-cam.y, w, h); }
function drawText(text, x, y, col='#fff', size=12, align='center') {
  ctx.fillStyle=col; ctx.font=`${size}px 'Courier New',monospace`; ctx.textAlign=align;
  ctx.fillText(text, x-cam.x, y-cam.y);
}

// ‚îÄ‚îÄ‚îÄ DRAW CHARACTER (programmatic pixel-art style) ‚îÄ‚îÄ‚îÄ
function drawCharacter(x, y, facing, walkFrame, colors, w=24, h=40, equipment=null) {
  const cx = x - cam.x;
  const cy = y - cam.y;
  const f = facing;
  const bob = Math.sin(walkFrame * 0.3) * 2;
  const legSwing = Math.sin(walkFrame * 0.6) * 6;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(cx, cy, w*0.6, 4, 0, 0, Math.PI*2);
  ctx.fill();

  // Legs
  ctx.fillStyle = colors.legs || '#2a2a4a';
  ctx.fillRect(cx - 6, cy - 14 + legSwing*0.5, 5, 14);
  ctx.fillRect(cx + 1, cy - 14 - legSwing*0.5, 5, 14);

  // Body
  ctx.fillStyle = colors.body || '#3a3a5a';
  ctx.fillRect(cx - 8, cy - 30 + bob, 16, 18);

  // Cape
  if(equipment?.cape) {
    const capeColors = {fire:'#cc3300',infernal:'#ff4400',max:'#d4a017',accumulator:'#336633'};
    ctx.fillStyle = capeColors[equipment.cape] || '#333';
    ctx.fillRect(cx - 6*f - (f>0?8:0), cy - 28 + bob, 8, 16);
  }

  // Arms
  ctx.fillStyle = colors.arms || colors.body || '#3a3a5a';
  const armSwing = Math.sin(walkFrame * 0.6) * 8;
  ctx.fillRect(cx - 11, cy - 28 + bob + armSwing*0.3, 4, 12);
  ctx.fillRect(cx + 7, cy - 28 + bob - armSwing*0.3, 4, 12);

  // Head
  ctx.fillStyle = colors.skin || '#c8a882';
  ctx.fillRect(cx - 5, cy - 40 + bob, 10, 10);

  // Helmet/hat
  ctx.fillStyle = colors.hat || '#4a4a5a';
  ctx.fillRect(cx - 7, cy - 44 + bob, 14, 6);
  if(equipment?.armor === 'torva' || equipment?.armor === 'ancestral') {
    ctx.fillRect(cx - 8, cy - 46 + bob, 16, 4); // visor
  }

  // Eyes
  ctx.fillStyle = '#fff';
  ctx.fillRect(cx + (f>0?1:-4), cy - 38 + bob, 2, 2);
  ctx.fillStyle = '#000';
  ctx.fillRect(cx + (f>0?2:-3), cy - 38 + bob, 1, 2);

  // Weapon
  if(equipment?.weapon) {
    const wx = cx + 10*f;
    const wy = cy - 24 + bob;
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 2;
    if(['godsword','whip','scimitar'].some(w=>equipment.weapon.includes(w))) {
      // Melee weapon
      ctx.strokeStyle = '#ccccdd';
      ctx.beginPath();
      ctx.moveTo(wx, wy);
      ctx.lineTo(wx + 16*f, wy - 20);
      ctx.stroke();
      // Blade tip
      ctx.fillStyle = '#d4a017';
      ctx.fillRect(wx + 14*f, wy - 22, 4, 4);
    } else if(equipment.weapon.includes('bow') || equipment.weapon.includes('crossbow')) {
      ctx.strokeStyle = '#6a4a2a';
      ctx.beginPath();
      ctx.moveTo(wx, wy - 15);
      ctx.quadraticCurveTo(wx + 10*f, wy, wx, wy + 10);
      ctx.stroke();
    } else {
      // Staff
      ctx.strokeStyle = '#5a3a1a';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(wx, wy + 5);
      ctx.lineTo(wx + 4*f, wy - 25);
      ctx.stroke();
      ctx.fillStyle = '#3388cc';
      ctx.beginPath();
      ctx.arc(wx + 4*f, wy - 28, 5, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

// ‚îÄ‚îÄ‚îÄ DRAW NPC ‚îÄ‚îÄ‚îÄ
function drawNPC(npc) {
  const bobVal = Math.sin(tick * 0.03 + npc.x) * 2;
  const facing = player.x > npc.x ? 1 : -1;

  drawCharacter(npc.x, npc.y, facing, bobVal, {
    body: npc.color, hat: npc.hat, skin:'#c8a882', legs:'#2a2a3a'
  }, 24, 40);

  // Name tag
  const dist = Math.abs(player.x - npc.x);
  if(dist < 200) {
    const alpha = Math.max(0, 1 - dist/200);
    ctx.globalAlpha = alpha;
    drawText(npc.name, npc.x, npc.y - 52, '#d4a017', 11);
    if(dist < 80) {
      drawText('[E] Talk', npc.x, npc.y - 64, '#888', 9);
    }
    ctx.globalAlpha = 1;
  }
}

// ‚îÄ‚îÄ‚îÄ DRAW WORLD OBJECTS ‚îÄ‚îÄ‚îÄ
function drawWorldObject(obj) {
  const ox = obj.x - cam.x;
  const oy = obj.y - cam.y;

  switch(obj.type) {
    case 'tree': {
      // Trunk
      ctx.fillStyle = '#3a2a1a';
      ctx.fillRect(ox + obj.w/2 - 6, oy, 12, obj.h);
      // Foliage
      ctx.fillStyle = obj.foliage || '#1a5a1a';
      ctx.beginPath();
      ctx.arc(ox + obj.w/2, oy - 10, obj.w/2 + 10, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = obj.foliage ? lighten(obj.foliage, 20) : '#2a6a2a';
      ctx.beginPath();
      ctx.arc(ox + obj.w/2 - 8, oy - 15, obj.w/3, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'dead_tree': {
      ctx.strokeStyle = '#3a2a1a';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(ox + obj.w/2, oy + obj.h);
      ctx.lineTo(ox + obj.w/2, oy);
      ctx.lineTo(ox, oy - 15);
      ctx.moveTo(ox + obj.w/2, oy + 15);
      ctx.lineTo(ox + obj.w, oy - 5);
      ctx.stroke();
      break;
    }
    case 'castle': {
      ctx.fillStyle = '#4a4a5a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      // Towers
      ctx.fillRect(ox - 15, oy - 40, 40, obj.h + 40);
      ctx.fillRect(ox + obj.w - 25, oy - 40, 40, obj.h + 40);
      // Battlements
      for(let i = 0; i < 4; i++) {
        ctx.fillRect(ox - 15 + i*12, oy - 52, 8, 12);
        ctx.fillRect(ox + obj.w - 25 + i*12, oy - 52, 8, 12);
      }
      // Gate
      ctx.fillStyle = '#2a1a0a';
      ctx.fillRect(ox + obj.w/2 - 20, oy + obj.h - 50, 40, 50);
      // Windows
      ctx.fillStyle = '#d4a017';
      ctx.fillRect(ox + 40, oy + 30, 12, 15);
      ctx.fillRect(ox + 100, oy + 30, 12, 15);
      ctx.fillRect(ox + 160, oy + 30, 12, 15);
      // Flag
      ctx.fillStyle = '#cc3333';
      ctx.fillRect(ox + obj.w/2 - 2, oy - 30, 4, -30);
      ctx.fillRect(ox + obj.w/2 + 2, oy - 58, 20, 12);
      break;
    }
    case 'house': {
      ctx.fillStyle = '#5a4a3a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = obj.roof || '#8a3a1a';
      ctx.beginPath();
      ctx.moveTo(ox - 10, oy);
      ctx.lineTo(ox + obj.w/2, oy - 30);
      ctx.lineTo(ox + obj.w + 10, oy);
      ctx.fill();
      ctx.fillStyle = '#2a1a0a';
      ctx.fillRect(ox + obj.w/2 - 12, oy + obj.h - 35, 24, 35);
      ctx.fillStyle = '#d4a017';
      ctx.fillRect(ox + 15, oy + 20, 10, 12);
      break;
    }
    case 'building': {
      ctx.fillStyle = '#5a5a6a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = obj.roof || '#5a2a2a';
      ctx.beginPath();
      ctx.moveTo(ox - 10, oy);
      ctx.lineTo(ox + obj.w/2, oy - 35);
      ctx.lineTo(ox + obj.w + 10, oy);
      ctx.fill();
      ctx.fillStyle = '#2a1a0a';
      ctx.fillRect(ox + obj.w/2 - 15, oy + obj.h - 40, 30, 40);
      if(obj.label) {
        ctx.fillStyle = '#d4a017';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(obj.label, ox + obj.w/2, oy - 40);
      }
      // Windows
      ctx.fillStyle = '#d4a017';
      ctx.fillRect(ox + 15, oy + 25, 12, 15);
      ctx.fillRect(ox + obj.w - 27, oy + 25, 12, 15);
      break;
    }
    case 'river': {
      const waveOffset = Math.sin(tick * 0.05) * 3;
      ctx.fillStyle = '#1a3a5a';
      ctx.fillRect(ox, oy + waveOffset, obj.w, obj.h);
      ctx.fillStyle = '#2a4a6a';
      for(let i = 0; i < obj.w; i += 20) {
        ctx.fillRect(ox + i + Math.sin(tick*0.08+i)*3, oy + waveOffset + 5, 10, 3);
      }
      break;
    }
    case 'bridge': {
      ctx.fillStyle = '#5a3a1a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = '#3a2a0a';
      ctx.fillRect(ox, oy, obj.w, 3);
      break;
    }
    case 'signpost': {
      ctx.fillStyle = '#5a3a1a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = obj.color || '#d4a017';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(obj.text, ox + obj.w/2, oy - 5);
      break;
    }
    case 'rock': {
      ctx.fillStyle = '#4a4a4a';
      ctx.beginPath();
      ctx.ellipse(ox + obj.w/2, oy + obj.h/2, obj.w/2, obj.h/2, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#5a5a5a';
      ctx.beginPath();
      ctx.ellipse(ox + obj.w/2 - 3, oy + obj.h/3, obj.w/3, obj.h/3, 0, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'fountain': {
      ctx.fillStyle = '#5a5a6a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = '#2a4a6a';
      ctx.fillRect(ox + 5, oy + 5, obj.w - 10, obj.h - 15);
      // Water spray
      const spray = Math.sin(tick * 0.1) * 5;
      ctx.fillStyle = '#4a7aaa';
      ctx.beginPath();
      ctx.arc(ox + obj.w/2, oy - 5 + spray, 4, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'statue': {
      ctx.fillStyle = '#6a6a7a';
      ctx.fillRect(ox + 5, oy + obj.h - 50, 20, 50);
      ctx.fillRect(ox, oy + obj.h - 10, 30, 10);
      ctx.beginPath();
      ctx.arc(ox + 15, oy + obj.h - 55, 8, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'wall_section': {
      ctx.fillStyle = obj.color || '#4a4a5a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      for(let i = 0; i < 5; i++) {
        ctx.fillRect(ox + (i%2)*20 - 5, oy - 8 + i*0, 12, 8);
      }
      break;
    }
    case 'ditch': {
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      break;
    }
    case 'bones': {
      ctx.fillStyle = '#c8c8aa';
      ctx.fillRect(ox, oy, obj.w*0.7, 3);
      ctx.fillRect(ox + 5, oy - 3, 3, 8);
      ctx.fillRect(ox + 15, oy - 2, 3, 7);
      break;
    }
    case 'skull_pile': {
      ctx.fillStyle = '#aaa88a';
      for(let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.arc(ox + 10 + i*10, oy + obj.h - 8, 7, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#222';
        ctx.fillRect(ox + 8 + i*10, oy + obj.h - 10, 2, 2);
        ctx.fillRect(ox + 12 + i*10, oy + obj.h - 10, 2, 2);
        ctx.fillStyle = '#aaa88a';
      }
      break;
    }
    case 'lava_pool': {
      const lavaGlow = 0.5 + Math.sin(tick * 0.08) * 0.3;
      ctx.fillStyle = `rgba(204,51,0,${lavaGlow})`;
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = `rgba(255,120,0,${lavaGlow*0.5})`;
      for(let i = 0; i < obj.w; i += 15) {
        ctx.beginPath();
        ctx.arc(ox + i + Math.sin(tick*0.06+i)*4, oy + obj.h/2, 5, 0, Math.PI*2);
        ctx.fill();
      }
      break;
    }
    case 'arena_gate': {
      ctx.fillStyle = '#3a3a5a';
      ctx.fillRect(ox, oy, 20, obj.h);
      ctx.fillRect(ox + obj.w - 20, oy, 20, obj.h);
      ctx.fillRect(ox, oy, obj.w, 25);
      // Arch
      ctx.fillStyle = '#d4a017';
      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('‚öî EMIR\'S ARENA ‚öî', ox + obj.w/2, oy + 16);
      // Torches on pillars
      const flicker = Math.sin(tick * 0.15) * 3;
      ctx.fillStyle = '#ff8800';
      ctx.beginPath();
      ctx.arc(ox + 10, oy - 5 + flicker, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(ox + obj.w - 10, oy - 5 - flicker, 6, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'arena_pillar': {
      ctx.fillStyle = obj.color || '#3a3a5a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = '#d4a017';
      ctx.fillRect(ox - 3, oy, obj.w + 6, 5);
      ctx.fillRect(ox - 3, oy + obj.h - 5, obj.w + 6, 5);
      break;
    }
    case 'arena_floor': {
      ctx.fillStyle = obj.color || '#1a1a3a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      // Grid lines
      ctx.strokeStyle = '#2a2a4a';
      ctx.lineWidth = 1;
      for(let i = 0; i < obj.w; i += 60) {
        ctx.beginPath();
        ctx.moveTo(ox + i, oy);
        ctx.lineTo(ox + i, oy + obj.h);
        ctx.stroke();
      }
      break;
    }
    case 'torch': {
      ctx.fillStyle = '#3a2a1a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      const f1 = Math.sin(tick*0.12 + obj.x)*4;
      const f2 = Math.cos(tick*0.15 + obj.x)*3;
      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.arc(ox + obj.w/2, oy - 5 + f1, 8, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#ffaa00';
      ctx.beginPath();
      ctx.arc(ox + obj.w/2 + f2, oy - 8, 4, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'duel_portal': {
      const pulse = 0.6 + Math.sin(tick * 0.08) * 0.3;
      ctx.fillStyle = '#3a244f';
      ctx.fillRect(ox + 20, oy + 24, 40, obj.h - 24);
      ctx.fillStyle = `rgba(125,85,255,${pulse})`;
      ctx.beginPath();
      ctx.ellipse(ox + obj.w/2, oy + obj.h/2 - 10, 26, 58, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#d4a017';
      ctx.lineWidth = 2;
      ctx.strokeRect(ox + 18, oy + 20, 44, obj.h - 20);
      ctx.fillStyle = '#d4a017';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('EMIR\'S', ox + obj.w / 2, oy + 14);
      ctx.fillText('PORTAL', ox + obj.w / 2, oy + obj.h + 14);
      break;
    }
    case 'area_portal': {
      const pulse = 0.55 + Math.sin(tick * 0.08 + obj.x * 0.01) * 0.25;
      const tint = obj.tint || '#4f67ff';
      ctx.fillStyle = '#2a2a44';
      ctx.fillRect(ox + 10, oy + 20, obj.w - 20, obj.h - 20);
      ctx.fillStyle = tint;
      ctx.globalAlpha = pulse;
      ctx.beginPath();
      ctx.ellipse(ox + obj.w/2, oy + obj.h/2 - 6, 18, 48, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#d4a017';
      ctx.lineWidth = 2;
      ctx.strokeRect(ox + 8, oy + 16, obj.w - 16, obj.h - 16);
      ctx.fillStyle = '#d4a017';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText((obj.label || 'Portal').toUpperCase().slice(0, 12), ox + obj.w / 2, oy + obj.h + 14);
      break;
    }
    case 'crystal': {
      ctx.fillStyle = obj.color || '#7f8dff';
      ctx.beginPath();
      ctx.moveTo(ox + obj.w/2, oy);
      ctx.lineTo(ox + obj.w, oy + obj.h*0.35);
      ctx.lineTo(ox + obj.w*0.74, oy + obj.h);
      ctx.lineTo(ox + obj.w*0.26, oy + obj.h);
      ctx.lineTo(ox, oy + obj.h*0.35);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#d4e1ff';
      ctx.lineWidth = 1;
      ctx.stroke();
      break;
    }
  }
}

function lighten(hex, amt) {
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  r = Math.min(255, r+amt); g = Math.min(255, g+amt); b = Math.min(255, b+amt);
  return `rgb(${r},${g},${b})`;
}

// ‚îÄ‚îÄ‚îÄ GET CURRENT ZONE ‚îÄ‚îÄ‚îÄ
function getZone(x) {
  const zones = getAreaZones();
  for(const z of zones) { if(x >= z.x && x < z.x + z.w) return z; }
  return zones[zones.length - 1];
}

// ‚îÄ‚îÄ‚îÄ DIALOGUE SYSTEM ‚îÄ‚îÄ‚îÄ
const dialogueBox = document.getElementById('dialogue-box');
function openDialogue(npc) {
  dialogueState = { npc, lineIndex: 0 };
  showDialogueLine();
}
function showDialogueLine() {
  if(!dialogueState) return;
  const {npc, lineIndex} = dialogueState;
  if(lineIndex >= npc.dialogue.length) { closeDialogue(); return; }
  dialogueBox.style.display = 'block';
  dialogueBox.querySelector('.speaker').textContent = npc.name;
  dialogueBox.querySelector('.text').textContent = npc.dialogue[lineIndex];
  if(npc.isArenaMaster && lineIndex === npc.dialogue.length - 1) {
    dialogueBox.querySelector('.prompt').textContent = '[E] Continue | [F] Register for Arena | [Q] Close';
  } else {
    dialogueBox.querySelector('.prompt').textContent = '[E] Continue | [Q] Close';
  }
}
function advanceDialogue() {
  if(!dialogueState) return;
  dialogueState.lineIndex++;
  showDialogueLine();
}
function closeDialogue() {
  dialogueState = null;
  dialogueBox.style.display = 'none';
}

// ‚îÄ‚îÄ‚îÄ ZONE LABEL ‚îÄ‚îÄ‚îÄ
const zoneLabelEl = document.getElementById('zone-label');
let lastZoneName = '';
function showZoneLabel(name) {
  if(name === lastZoneName) return;
  lastZoneName = name;
  zoneLabelEl.textContent = '~ ' + name + ' ~';
  zoneLabelEl.classList.add('show');
  setTimeout(() => zoneLabelEl.classList.remove('show'), 2500);
}

// ‚îÄ‚îÄ‚îÄ ARENA REGISTRATION ‚îÄ‚îÄ‚îÄ
const combatOverlay = document.getElementById('combat-overlay');

async function registerForArena() {
  if(player.registered) {
    showFloatingText('Already registered!', '#d4a017');
    return;
  }
  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = `
    <div style="text-align:center">
      <div style="color:#d4a017;font-size:16px;margin-bottom:12px">‚öî ARENA REGISTRATION ‚öî</div>
      <div style="margin-bottom:8px;color:#aaa">Choose your combat class:</div>
      <div style="display:flex;gap:10px;justify-content:center;margin-bottom:12px">
        <button onclick="selectClass('melee')" style="padding:8px 16px;background:#cc3333;border:2px solid #ff4444;color:#fff;cursor:pointer;font-family:monospace;font-size:13px">‚öî Melee</button>
        <button onclick="selectClass('ranged')" style="padding:8px 16px;background:#33cc33;border:2px solid #44ff44;color:#fff;cursor:pointer;font-family:monospace;font-size:13px">üèπ Ranged</button>
        <button onclick="selectClass('magic')" style="padding:8px 16px;background:#3388cc;border:2px solid #44aaff;color:#fff;cursor:pointer;font-family:monospace;font-size:13px">‚ú¶ Magic</button>
      </div>
      <div style="color:#666;font-size:11px">Press Q to cancel</div>
    </div>`;
}

window.selectClass = async function(cls) {
  const id = 'Player_' + Math.random().toString(36).slice(2,6);
  try {
    const res = await fetch(API + '/register', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({agent_id: id, combat_class: cls, prayer_book: 'normal'})
    });
    const data = await res.json();
    if(data.status === 'registered' && data.agent?.agent_id) {
      player.agent_id = data.agent.agent_id;
      player.combat_class = cls;
      player.registered = true;
      player.area_id = DEFAULT_AREA_ID;
      player.instance_id = null;
      combatOverlay.style.display = 'none';
      registrationOpen = false;
      showFloatingText(`Registered as ${cls}! ID: ${id}`, '#33cc33');

      // Update equipment based on class
      player.equipment = getEquipmentForClass(cls);

      connectWorldSocket();
      sendWorldUpdate(true);
      await loadProfile();
      await fetchResourceNodes();
    } else {
      showFloatingText(data.error || 'Registration failed!', '#cc3333');
    }
  } catch(e) { showFloatingText('Registration failed!', '#cc3333'); }
};

function setWorldStateFromServer(world) {
  if(!world) return;
  if(typeof world.x === 'number') player.x = world.x;
  if(typeof world.y === 'number') player.y = world.y;
  player.area_id = world.area_id || DEFAULT_AREA_ID;
  player.instance_id = world.instance_id || null;
  worldAgents.clear();
  resourceNodes.clear();
  currentZone = getZone(player.x);
  if(worldWs && worldWs.readyState === WebSocket.OPEN) {
    worldWs.send(JSON.stringify({
      type:'world_subscribe',
      area_id: player.area_id,
      instance_id: player.instance_id,
    }));
  }
}

async function loadProfile() {
  if(!player.agent_id) return;
  try {
    const res = await fetch('/api/v1/profile/' + player.agent_id);
    if(!res.ok) return;
    const data = await res.json();
    player.skills = data.progress?.skills || player.skills;
    player.inventory = data.progress?.inventory || player.inventory;
    queuedForDuel = !!data.queue;
    if(data.world) {
      setWorldStateFromServer(data.world);
    }
  } catch {}
}

async function fetchResourceNodes() {
  try {
    const areaId = encodeURIComponent(player.area_id || DEFAULT_AREA_ID);
    const instanceParam = player.instance_id ? `&instance_id=${encodeURIComponent(player.instance_id)}` : '';
    const res = await fetch(`/api/v1/world/nodes?area_id=${areaId}${instanceParam}`);
    if(!res.ok) return;
    const nodes = await res.json();
    if(Array.isArray(nodes)) {
      resourceNodes.clear();
      nodes.forEach(node => resourceNodes.set(node.node_id, node));
    }
  } catch {}
}

function openDuelQueueOverlay() {
  if(!player.registered || !player.agent_id) {
    registerForArena();
    return;
  }

  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = `
    <div style="text-align:center">
      <div style="color:#d4a017;font-size:16px;margin-bottom:10px">‚öî EMIR'S ARENA QUEUE ‚öî</div>
      <div style="margin-bottom:8px;color:#aaa">${queuedForDuel ? 'You are currently queued for a duel.' : 'Join the queue to find a duel.'}</div>
      <div style="display:flex;gap:10px;justify-content:center;margin-bottom:10px">
        <button onclick="joinDuelQueue()" style="padding:8px 16px;background:#2c7;border:2px solid #4fa;color:#fff;cursor:pointer;font-family:monospace;font-size:13px">Join Queue</button>
        <button onclick="leaveDuelQueue()" style="padding:8px 16px;background:#933;border:2px solid #c55;color:#fff;cursor:pointer;font-family:monospace;font-size:13px">Leave Queue</button>
      </div>
      <div style="color:#888;font-size:11px">Queue size: ${duelQueue.length}</div>
      <div style="color:#666;font-size:11px;margin-top:6px">Press Q to close</div>
    </div>`;
}

window.joinDuelQueue = async function() {
  if(!player.agent_id) return;
  try {
    const res = await fetch('/api/v1/world/portal/use', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        agent_id: player.agent_id,
        portal_id: 'emirs_arena_portal',
        arena: 'duel_arena',
      })
    });
    const data = await res.json();
    if(res.ok) {
      queuedForDuel = true;
      showFloatingText(`Queued (${data.queue_size})`, '#d4a017');
      openDuelQueueOverlay();
    } else {
      showFloatingText(data.error || 'Queue failed', '#cc3333');
    }
  } catch(e) {
    showFloatingText('Queue failed', '#cc3333');
  }
};

window.leaveDuelQueue = async function() {
  if(!player.agent_id) return;
  try {
    const res = await fetch('/api/v1/arena/queue/leave', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ agent_id: player.agent_id })
    });
    await res.json();
    queuedForDuel = false;
    showFloatingText('Left queue', '#999');
    openDuelQueueOverlay();
  } catch {}
};

async function openSpellbookOverlay() {
  if(!player.agent_id) {
    registerForArena();
    return;
  }

  try {
    const res = await fetch('/api/v1/world/spellbook/' + player.agent_id);
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Spellbook unavailable', '#cc3333');
      return;
    }
    player.spellbook = data.spells || [];
    registrationOpen = true;
    combatOverlay.style.display = 'block';
    combatOverlay.innerHTML = `
      <div style=\"text-align:left;max-height:360px;overflow:auto;min-width:520px\">
        <div style=\"text-align:center;color:#7fa1ff;font-size:16px;margin-bottom:10px\">‚ú¶ SPELLBOOK ‚ú¶</div>
        <div style=\"color:#aaa;margin-bottom:8px\">Magic: ${data.magic_level} | Runecrafting: ${data.runecrafting_level}</div>
        <div style=\"display:grid;grid-template-columns:1fr;gap:6px\">
          ${(data.spells || []).map((spell) => {
            const runes = spell.runes.map((r) => `${r.item_id.replace('_',' ')} ${r.qty_owned}/${r.qty_required}`).join(' ‚Ä¢ ');
            const buttonLabel = spell.teleport ? 'Cast Teleport' : 'Cast';
            const disabled = spell.can_cast ? '' : 'disabled';
            const bg = spell.can_cast ? '#294d9f' : '#333';
            return `<div style=\"border:1px solid #445;padding:8px;background:rgba(20,20,40,.75)\">
              <div style=\"display:flex;justify-content:space-between;align-items:center;gap:10px\">
                <div>
                  <div style=\"color:#d4e1ff;font-size:13px\">${spell.spell}</div>
                  <div style=\"color:#9ab0ff;font-size:11px\">Requires magic ${spell.magic_level_required}</div>
                  <div style=\"color:#8a8a9a;font-size:11px\">${runes}</div>
                </div>
                <button onclick=\"castSpell('${spell.spell}')\" ${disabled} style=\"padding:6px 10px;background:${bg};border:1px solid #678;color:#fff;cursor:pointer;font-family:monospace;font-size:11px\">${buttonLabel}</button>
              </div>
            </div>`;
          }).join('')}
        </div>
        <div style=\"text-align:center;color:#666;font-size:11px;margin-top:8px\">Press Q or B to close</div>
      </div>`;
  } catch {
    showFloatingText('Spellbook unavailable', '#cc3333');
  }
}

window.castSpell = async function(spellName) {
  if(!player.agent_id) return;
  try {
    const res = await fetch('/api/v1/world/spell/cast', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ agent_id: player.agent_id, spell: spellName }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Spell failed', '#cc3333');
      return;
    }

    if(data.inventory) player.inventory = data.inventory;
    if(data.gain?.skill) {
      const existing = player.skills[data.gain.skill] || { level: 1, xp: 0 };
      existing.level = data.gain.new_level;
      existing.xp = data.gain.total_xp;
      player.skills[data.gain.skill] = existing;
      showFloatingText(`${spellName} cast`, '#7fa1ff');
    }
    if(data.world) {
      setWorldStateFromServer(data.world);
      await fetchResourceNodes();
      sendWorldUpdate(true);
      showZoneLabel(getZone(player.x)?.name || 'Unknown');
    }
    await openSpellbookOverlay();
  } catch {
    showFloatingText('Spell failed', '#cc3333');
  }
};

async function startArenaFightFromMatch(fightId) {
  if(!fightId || !player.agent_id) return;
  try {
    if(skillActionNodeId) {
      fetch('/api/v1/world/interact', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({agent_id:player.agent_id,node_id:skillActionNodeId,action:'stop'})
      }).catch(()=>{});
      skillActionNodeId = null;
    }

    const res = await fetch(API + '/fight/' + fightId);
    if(!res.ok) return;
    const fight = await res.json();

    const isP1 = fight.p1.agent_id === player.agent_id;
    const opponentState = isP1 ? fight.p2 : fight.p1;
    const selfState = isP1 ? fight.p1 : fight.p2;

    player.inFight = true;
    worldReturnPoint = {
      x: player.x,
      y: player.y,
      area_id: player.area_id || DEFAULT_AREA_ID,
      instance_id: player.instance_id || null,
    };
    leaveWorldPresence();

    arenaFight = {
      fight_id: fightId,
      opponent: {
        id: opponentState.agent_id,
        class: opponentState.combat_class,
        hp: opponentState.hp,
        maxHp: 99,
        prayer: opponentState.prayer,
        maxPrayer: 99,
        x: 10800,
        y: GROUND_Y,
        facing: -1,
      },
      playerSlot: isP1 ? 'p1' : 'p2',
      tick: fight.tick || 0,
      status: 'active',
      round: fight.round || 1,
      roundsWon: fight.rounds_won || { p1: 0, p2: 0 },
      lastNarrative: '',
    };

    player.hp = selfState.hp;
    player.prayer = selfState.prayer;
    player.x = 10000;
    combatLog = [`Fight started! ${player.agent_id} vs ${opponentState.agent_id}`];
    showFloatingText('MATCH FOUND', '#d4a017');

    if(worldWs && worldWs.readyState === WebSocket.OPEN) {
      worldWs.send(JSON.stringify({ type: 'spectate', fight_id: fightId }));
    }

    runArenaLoop();
  } catch(e) {
    showFloatingText('Failed to start duel', '#cc3333');
  }
}

// ‚îÄ‚îÄ‚îÄ ARENA COMBAT LOOP ‚îÄ‚îÄ‚îÄ
const PLAYER_ATTACKS = {
  melee: ['godsword_smash','whip_flick','slash','crush','stab'],
  ranged: ['crossbow_bolt','rapid_shot','longrange_shot','knife_throw','dark_bow_spec'],
  magic: ['ice_barrage','fire_blast','blood_barrage','entangle','teleblock','vengeance'],
};
const PLAYER_SPECIALS = {
  melee: ['ags_spec','dds_spec','gmaul_spec','vls_spec','claws_spec','none'],
  ranged: ['dbow_spec','zcb_spec','none'],
  magic: ['staff_spec','sgs_spec','none'],
};
const PLAYER_PRAYERS = {
  melee: ['protect_magic','smite','piety','none'],
  ranged: ['protect_melee','smite','rigour','none'],
  magic: ['protect_ranged','smite','augury','none'],
};
const FOODS = ['eat_shark','karambwan','brew_sip','combo_eat','none'];

function scheduleNextArenaLoop(ms = 800) {
  if(arenaLoopTimer) clearTimeout(arenaLoopTimer);
  arenaLoopTimer = setTimeout(runArenaLoop, ms);
}

async function runArenaLoop() {
  if(!arenaFight || arenaFight.status !== 'active') return;

  // Player auto-action
  const pAttacks = PLAYER_ATTACKS[player.combat_class];
  const pSpecials = PLAYER_SPECIALS[player.combat_class];
  const pPrayers = PLAYER_PRAYERS[player.combat_class];

  const pAttack = pAttacks[Math.floor(Math.random()*pAttacks.length)];
  const pSpecial = Math.random() < 0.3 ? pSpecials[Math.floor(Math.random()*pSpecials.length)] : 'none';
  const pPrayer = pPrayers[Math.floor(Math.random()*pPrayers.length)];
  const pFood = player.hp < 40 ? FOODS[Math.floor(Math.random()*FOODS.length)] : 'none';

  try {
    const actionRes = await fetch(API+'/action', {method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({agent_id:player.agent_id,fight_id:arenaFight.fight_id,
        action:pAttack,special:pSpecial||'none',food:pFood,prayer:pPrayer})});
    const actionData = await actionRes.json();

    // If queue fallback produced a bot, this client drives bot turns.
    if(arenaFight.opponent.id.startsWith('QueueBot_')) {
      const botClass = arenaFight.opponent.class;
      const botAttacks = PLAYER_ATTACKS[botClass];
      const botSpecials = PLAYER_SPECIALS[botClass];
      const botPrayers = PLAYER_PRAYERS[botClass];
      const botAttack = botAttacks[Math.floor(Math.random()*botAttacks.length)];
      const botSpecial = Math.random() < 0.3 ? botSpecials[Math.floor(Math.random()*botSpecials.length)] : 'none';
      const botPrayer = botPrayers[Math.floor(Math.random()*botPrayers.length)];
      const botFood = arenaFight.opponent.hp < 40 ? FOODS[Math.floor(Math.random()*FOODS.length)] : 'none';

      const res = await fetch(API+'/action', {method:'POST',headers:{'Content-Type':'application/json'},
        body:JSON.stringify({agent_id:arenaFight.opponent.id,fight_id:arenaFight.fight_id,
          action:botAttack,special:botSpecial||'none',food:botFood,prayer:botPrayer})});
      const data = await res.json();
      if(data.fight) {
        const hasResolved = data.result && typeof data.result.tick === 'number';
        const advanced = typeof data.fight.tick === 'number' && arenaFight && data.fight.tick > arenaFight.tick;
        if(hasResolved || advanced) {
          applyFightUpdate(data.fight, data.result || data.fight.last_result || null);
        }
      }
    } else if(actionData.fight) {
      const hasResolved = actionData.result && typeof actionData.result.tick === 'number';
      const advanced = typeof actionData.fight.tick === 'number' && arenaFight && actionData.fight.tick > arenaFight.tick;
      if(hasResolved || advanced) {
        applyFightUpdate(actionData.fight, actionData.result || actionData.fight.last_result || null);
      }
    } else {
      // For real PvP, state arrives via websocket tick_update. Poll fallback:
      const stateRes = await fetch(API + '/fight/' + arenaFight.fight_id);
      if(stateRes.ok) {
        const state = await stateRes.json();
        applyFightUpdate(state, state.last_result || null, false);
      }
    }
  } catch(e) {
    combatLog.push('Error: ' + e.message);
  }

  if(arenaFight && arenaFight.status === 'active') {
    scheduleNextArenaLoop(800);
  }
}

function applyFightUpdate(f, tickResult, allowRoundTransition = true) {
  if(!arenaFight || !f) return;

  const isP1 = f.p1.agent_id === player.agent_id;
  const selfState = isP1 ? f.p1 : f.p2;
  const oppState = isP1 ? f.p2 : f.p1;
  const prevTick = arenaFight.tick;

  const prevPlayerHp = player.hp;
  const prevOpHp = arenaFight.opponent.hp;

  player.hp = selfState.hp;
  player.prayer = selfState.prayer;
  arenaFight.opponent.hp = oppState.hp;
  arenaFight.opponent.prayer = oppState.prayer;
  arenaFight.tick = f.tick;
  arenaFight.round = f.round;
  arenaFight.roundsWon = f.rounds_won;
  arenaFight.lastNarrative = tickResult?.narrative || '';

  const hasFreshTick = !!tickResult && typeof tickResult.tick === 'number' && tickResult.tick > prevTick;

  // Spawn hit splats only on fresh tick resolves.
  const pDmg = prevPlayerHp - player.hp;
  const oDmg = prevOpHp - arenaFight.opponent.hp;
  if(hasFreshTick) {
    if(pDmg > 0) { spawnHitsplat(player.x, player.y - 50, pDmg, 'damage'); cam.shake = 5; }
    if(pDmg < 0) spawnHitsplat(player.x, player.y - 50, Math.abs(pDmg), 'heal');
    if(oDmg > 0) spawnHitsplat(arenaFight.opponent.x, arenaFight.opponent.y - 50, oDmg, 'damage');
    if(oDmg < 0) spawnHitsplat(arenaFight.opponent.x, arenaFight.opponent.y - 50, Math.abs(oDmg), 'heal');

    spawnAttackAnimation(player.x, player.y, arenaFight.opponent.x, player.combat_class);
    spawnAttackAnimation(arenaFight.opponent.x, arenaFight.opponent.y, player.x, arenaFight.opponent.class);
  }

  if(hasFreshTick && typeof arenaFight.lastNarrative === 'string' && arenaFight.lastNarrative.length > 0) {
    combatLog.push(`T${tickResult.tick}: ${arenaFight.lastNarrative}`);
  }
  while(combatLog.length > 8) combatLog.shift();

  if(f.status === 'fight_over') {
    arenaFight.status = 'fight_over';
    const won = (isP1 ? f.rounds_won.p1 : f.rounds_won.p2) > (isP1 ? f.rounds_won.p2 : f.rounds_won.p1);
    showFloatingText(won ? 'VICTORY!' : 'DEFEAT!', won ? '#d4a017' : '#cc3333');
    combatLog.push(won ? 'üèÜ You won the fight!' : 'üíÄ You lost the fight.');
    if(arenaLoopTimer) clearTimeout(arenaLoopTimer);
    setTimeout(() => {
      player.inFight = false;
      arenaFight = null;
      player.hp = player.maxHp;
      player.prayer = player.maxPrayer;
      if(worldReturnPoint) {
        player.x = worldReturnPoint.x;
        player.y = worldReturnPoint.y;
        player.area_id = worldReturnPoint.area_id;
        player.instance_id = worldReturnPoint.instance_id;
        worldReturnPoint = null;
      }
      if(worldWs && worldWs.readyState === WebSocket.OPEN) {
        worldWs.send(JSON.stringify({
          type:'world_subscribe',
          area_id: player.area_id || DEFAULT_AREA_ID,
          instance_id: player.instance_id || null,
        }));
        fetchResourceNodes().catch(()=>{});
        sendWorldUpdate(true);
      }
    }, 3500);
    return;
  }

  if(f.status === 'round_over' && allowRoundTransition) {
    combatLog.push(`--- Round ${f.round + 1} ---`);
    fetch(API+'/next-round', {method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({fight_id:arenaFight.fight_id})}).catch(()=>{});
  }
}

function spawnAttackAnimation(fromX, fromY, toX, combatClass) {
  const color = combatClass==='melee'?'#cc3333':combatClass==='ranged'?'#33cc33':'#3388cc';
  arenaAnimations.push({
    x: fromX, y: fromY - 25,
    tx: toX, ty: fromY - 25,
    progress: 0, speed: combatClass==='magic'?0.04:combatClass==='ranged'?0.06:0.1,
    color, type: combatClass,
  });
}

function showFloatingText(text, color) {
  spawnParticle(player.x, player.y - 80, 'text', text, color);
}

function getNearestResourceNode(maxDist = 90) {
  let best = null;
  let bestDist = Infinity;
  resourceNodes.forEach(node => {
    if(!isSameShard(node.area_id, node.instance_id)) return;
    const depleted = node.depleted_until && node.depleted_until > Date.now();
    if(depleted) return;
    const d = Math.abs(node.x - player.x);
    if(d < maxDist && d < bestDist) {
      best = node;
      bestDist = d;
    }
  });
  return best;
}

async function toggleResourceInteraction(node) {
  if(!player.agent_id) return;
  try {
    if(skillActionNodeId === node.node_id) {
      await fetch('/api/v1/world/interact', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({agent_id:player.agent_id,node_id:node.node_id,action:'stop'})
      });
      skillActionNodeId = null;
      showFloatingText('Stopped gathering', '#999');
      return;
    }

    const res = await fetch('/api/v1/world/interact', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({agent_id:player.agent_id,node_id:node.node_id,action:'start'})
    });
    const data = await res.json();
    if(res.ok) {
      skillActionNodeId = node.node_id;
      showFloatingText(`${node.skill}...`, '#66d4ff');
    } else {
      showFloatingText(data.error || 'Cannot gather', '#cc3333');
    }
  } catch {
    showFloatingText('Interaction failed', '#cc3333');
  }
}

function getNearbyPortalObject(maxDist = 110) {
  let best = null;
  let bestDist = Infinity;
  for(const obj of worldObjects) {
    const areaId = obj.area_id || DEFAULT_AREA_ID;
    if(areaId !== (player.area_id || DEFAULT_AREA_ID)) continue;
    if(!obj.portal_id) continue;
    const centerX = obj.x + obj.w / 2;
    const d = Math.abs(centerX - player.x);
    if(d < maxDist && d < bestDist) {
      best = obj;
      bestDist = d;
    }
  }
  return best;
}

async function useWorldPortal(portalObj) {
  if(!player.agent_id || !portalObj?.portal_id) return;
  try {
    const res = await fetch('/api/v1/world/portal/use', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        agent_id: player.agent_id,
        portal_id: portalObj.portal_id,
        scope: portalObj.portal_scope || 'shared',
        arena: portalObj.portal_kind === 'duel_queue' ? 'duel_arena' : undefined,
      }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Portal failed', '#cc3333');
      return;
    }
    if(data.status === 'portal_queued') {
      queuedForDuel = true;
      showFloatingText(`Queued (${data.queue_size})`, '#d4a017');
      openDuelQueueOverlay();
      return;
    }
    if(data.world) {
      setWorldStateFromServer(data.world);
      await fetchResourceNodes();
      sendWorldUpdate(true);
      showZoneLabel(getZone(player.x)?.name || 'New Area');
      showFloatingText(`Entered ${data.area?.name || 'new area'}`, '#66d4ff');
    }
  } catch {
    showFloatingText('Portal failed', '#cc3333');
  }
}

function isNearDuelPortal() {
  const portal = getNearbyPortalObject(120);
  return !!(portal && portal.portal_kind === 'duel_queue');
}

// ‚îÄ‚îÄ‚îÄ UPDATE ‚îÄ‚îÄ‚îÄ
function update() {
  tick++;

  if(keys['q'] && registrationOpen) {
    keys['q'] = false;
    combatOverlay.style.display = 'none';
    registrationOpen = false;
  }
  if(keys['b'] && registrationOpen) {
    keys['b'] = false;
    combatOverlay.style.display = 'none';
    registrationOpen = false;
  }

  // Player movement
  if(!dialogueState && !registrationOpen) {
    const speed = keys['shift'] ? 4 : 2;
    if(keys['a'] || keys['arrowleft']) { player.vx = -speed; player.facing = -1; }
    else if(keys['d'] || keys['arrowright']) { player.vx = speed; player.facing = 1; }
    else { player.vx *= 0.8; }

    if((keys[' '] || keys['w'] || keys['arrowup']) && player.onGround) {
      player.vy = -10;
      player.onGround = false;
    }

    // Interact
    if(keys['e']) {
      keys['e'] = false;
      if(dialogueState) { advanceDialogue(); }
      else {
        const nearbyNode = getNearestResourceNode();
        const nearbyPortal = getNearbyPortalObject();
        if(nearbyNode && !player.inFight) {
          toggleResourceInteraction(nearbyNode);
        } else if(nearbyPortal && !player.inFight) {
          if(nearbyPortal.portal_kind === 'duel_queue') openDuelQueueOverlay();
          else useWorldPortal(nearbyPortal);
        } else {
          const nearNpc = npcs.find(n =>
            (n.area_id || DEFAULT_AREA_ID) === (player.area_id || DEFAULT_AREA_ID) &&
            Math.abs(n.x - player.x) < 60
          );
          if(nearNpc) openDialogue(nearNpc);
        }
      }
    }
    if(keys['q']) {
      keys['q'] = false;
      if(dialogueState) closeDialogue();
      if(registrationOpen) { combatOverlay.style.display = 'none'; registrationOpen = false; }
      if(skillActionNodeId && player.agent_id) {
        fetch('/api/v1/world/interact', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body:JSON.stringify({agent_id:player.agent_id,node_id:skillActionNodeId,action:'stop'})
        }).catch(()=>{});
        skillActionNodeId = null;
      }
    }
    if(keys['b']) {
      keys['b'] = false;
      if(registrationOpen) {
        combatOverlay.style.display = 'none';
        registrationOpen = false;
      } else {
        openSpellbookOverlay();
      }
    }
    if(keys['f']) {
      keys['f'] = false;
      const nearArenaMaster = npcs.find(n =>
        n.isArenaMaster &&
        (n.area_id || DEFAULT_AREA_ID) === (player.area_id || DEFAULT_AREA_ID) &&
        Math.abs(n.x - player.x) < 100
      );
      if(nearArenaMaster) registerForArena();
    }
  }

  // Physics
  player.x += player.vx;
  player.vy += GRAVITY;
  player.y += player.vy;
  if(player.y >= GROUND_Y) { player.y = GROUND_Y; player.vy = 0; player.onGround = true; }
  const areaWidth = getAreaWidth();
  player.x = Math.max(20, Math.min(areaWidth - 20, player.x));

  // Walk animation
  if(Math.abs(player.vx) > 0.5) { player.walkTimer += Math.abs(player.vx) * 0.15; }

  // Camera
  const targetCamX = player.x - W/2;
  const targetCamY = Math.min(0, player.y - H/2 + 100);
  cam.x += (targetCamX - cam.x) * 0.08;
  cam.y += (targetCamY - cam.y) * 0.08;
  cam.x = Math.max(0, Math.min(areaWidth - W, cam.x));

  // Camera shake
  if(cam.shake > 0) {
    cam.x += (Math.random()-0.5) * cam.shake * 2;
    cam.y += (Math.random()-0.5) * cam.shake * 2;
    cam.shake *= 0.85;
    if(cam.shake < 0.3) cam.shake = 0;
  }

  // Zone detection
  currentZone = getZone(player.x);
  showZoneLabel(currentZone.name);
  sendWorldUpdate();

  // Particles
  particles = particles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.05;
    p.life -= 0.02;
    return p.life > 0;
  });

  // Arena animations
  arenaAnimations = arenaAnimations.filter(a => {
    a.progress += a.speed;
    return a.progress < 1;
  });

  // Clouds
  clouds.forEach(c => { c.x += c.speed; if(c.x > WORLD_W + 200) c.x = -200; });
}

// ‚îÄ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ‚îÄ
function render() {
  ctx.clearRect(0, 0, W, H);

  // Sky gradient based on zone
  const zone = currentZone;
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, zone.sky);
  grad.addColorStop(1, zone.name === 'Wilderness' || zone.name === 'Wilderness Border' ? '#1a0505' : '#0a0a15');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  ctx.fillStyle = '#fff';
  stars.forEach(s => {
    const sx = s.x - cam.x * 0.1;
    const twinkle = 0.3 + Math.sin(tick * 0.02 + s.b * 100) * 0.7;
    ctx.globalAlpha = twinkle * 0.6;
    ctx.fillRect(sx % W, s.y, s.s, s.s);
  });
  ctx.globalAlpha = 1;

  // Clouds
  ctx.fillStyle = 'rgba(40,40,60,0.3)';
  clouds.forEach(c => {
    const cx = c.x - cam.x * 0.3;
    ctx.beginPath();
    ctx.ellipse(cx, c.y, c.w/2, 15, 0, 0, Math.PI*2);
    ctx.fill();
  });

  // Mountains (parallax)
  ctx.fillStyle = '#1a1a2a';
  for(let i = 0; i < W + 200; i += 200) {
    const mx = i - (cam.x * 0.2) % 200;
    const mh = 80 + Math.sin(i * 0.01 + 1) * 40;
    ctx.beginPath();
    ctx.moveTo(mx, GROUND_Y - cam.y);
    ctx.lineTo(mx + 100, GROUND_Y - mh - cam.y);
    ctx.lineTo(mx + 200, GROUND_Y - cam.y);
    ctx.fill();
  }

  // Hills (parallax)
  ctx.fillStyle = '#151525';
  for(let i = 0; i < W + 300; i += 300) {
    const hx = i - (cam.x * 0.4) % 300;
    ctx.beginPath();
    ctx.arc(hx + 150, GROUND_Y - cam.y + 20, 160, Math.PI, 0);
    ctx.fill();
  }

  // Ground ‚Äî per zone coloring
  const zones = getAreaZones();
  for(const z of zones) {
    const gx = z.x - cam.x;
    const gy = GROUND_Y - cam.y;
    if(gx + z.w < 0 || gx > W) continue;
    // Ground top
    ctx.fillStyle = z.groundTop;
    ctx.fillRect(gx, gy, z.w, 6);
    // Ground body
    ctx.fillStyle = z.ground;
    ctx.fillRect(gx, gy + 6, z.w, H - gy);
  }

  // Zone transition effects
  if(currentZone.name === 'Wilderness' || currentZone.name === 'Wilderness Border') {
    // Red vignette
    const vg = ctx.createRadialGradient(W/2, H/2, H*0.3, W/2, H/2, H);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(100,0,0,0.3)');
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, W, H);
  }

  // World objects
  worldObjects.forEach(o => {
    const areaId = o.area_id || DEFAULT_AREA_ID;
    if(areaId !== (player.area_id || DEFAULT_AREA_ID)) return;
    if(o.x + o.w + 100 > cam.x && o.x - 100 < cam.x + W) drawWorldObject(o);
  });

  // Resource nodes
  resourceNodes.forEach(node => {
    if(Math.abs(node.x - cam.x - W / 2) > W) return;
    const nx = node.x - cam.x;
    const ny = GROUND_Y - cam.y - 10;
    const depleted = node.depleted_until && node.depleted_until > Date.now();
    const isActive = skillActionNodeId === node.node_id;
    const skillColor = node.skill === 'mining'
      ? '#b0b0b0'
      : node.skill === 'fishing'
      ? '#44aaff'
      : node.skill === 'runecrafting'
      ? '#7f8dff'
      : '#66aa44';

    ctx.fillStyle = depleted ? '#444' : skillColor;
    ctx.beginPath();
    ctx.arc(nx, ny, depleted ? 8 : 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = isActive ? '#d4a017' : '#222';
    ctx.lineWidth = isActive ? 2 : 1;
    ctx.stroke();

    const near = Math.abs(node.x - player.x) < 85 && !player.inFight;
    if(near) {
      ctx.fillStyle = '#d4a017';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      const suffix = depleted ? ' (depleted)' : '';
      ctx.fillText(`${node.skill} ${node.level_required}+${suffix}`, nx, ny - 16);
      if(!depleted) {
        ctx.fillStyle = '#999';
        ctx.fillText('[E] Gather', nx, ny - 27);
      }
    }
  });

  // NPCs
  npcs.forEach(npc => {
    const areaId = npc.area_id || DEFAULT_AREA_ID;
    if(areaId !== (player.area_id || DEFAULT_AREA_ID)) return;
    if(Math.abs(npc.x - cam.x - W/2) < W) drawNPC(npc);
  });

  // Portal hint
  const nearbyPortal = getNearbyPortalObject(120);
  if(nearbyPortal && !player.inFight) {
    ctx.fillStyle = '#d4a017';
    ctx.font = '11px Courier New';
    ctx.textAlign = 'center';
    const centerX = nearbyPortal.x + nearbyPortal.w / 2;
    const label = nearbyPortal.portal_kind === 'duel_queue' ? '[E] Duel Queue' : `[E] ${nearbyPortal.label || 'Use Portal'}`;
    ctx.fillText(label, centerX - cam.x, GROUND_Y - cam.y - 170);
  }

  // Other connected agents in the open world
  worldAgents.forEach((agent) => {
    if(Math.abs(agent.x - cam.x - W/2) > W) return;
    const equipment = getEquipmentForClass(agent.combat_class);
    drawCharacter(agent.x, agent.y, player.x > agent.x ? 1 : -1, tick * 0.08, {
      body: agent.combat_class === 'melee' ? '#aa3333' : agent.combat_class === 'ranged' ? '#339944' : '#3366aa',
      hat: agent.combat_class === 'melee' ? '#7a2222' : agent.combat_class === 'ranged' ? '#226622' : '#224477',
      skin: '#c8a882',
      legs: '#2a2a3a',
      arms: agent.combat_class === 'melee' ? '#993333' : agent.combat_class === 'ranged' ? '#2f8b3f' : '#335999',
    }, 24, 40, equipment);

    drawText(agent.agent_id, agent.x, agent.y - 56, '#66d4ff', 9);
  });

  // Arena opponent
  if(arenaFight && arenaFight.opponent) {
    const op = arenaFight.opponent;
    const opEquip = getEquipmentForClass(op.class);
    drawCharacter(op.x, op.y, op.facing, tick*0.1, {
      body: op.class==='melee'?'#aa3333':op.class==='ranged'?'#33aa33':'#3366aa',
      hat: op.class==='melee'?'#882222':op.class==='ranged'?'#228822':'#224488',
      skin:'#b89a72', legs:'#2a2a3a', arms: op.class==='melee'?'#993333':op.class==='ranged'?'#339933':'#335599'
    }, 24, 40, opEquip);

    // Opponent HP bar
    const ohx = op.x - cam.x - 20;
    const ohy = op.y - cam.y - 60;
    ctx.fillStyle = '#333';
    ctx.fillRect(ohx, ohy, 40, 5);
    ctx.fillStyle = op.hp > 30 ? '#33cc33' : '#cc3333';
    ctx.fillRect(ohx, ohy, 40 * (op.hp/op.maxHp), 5);
    drawText(op.id, op.x, op.y - 70, '#cc5555', 10);
  }

  // Arena attack animations
  arenaAnimations.forEach(a => {
    const cx = a.x + (a.tx - a.x) * a.progress;
    const cy = a.y + Math.sin(a.progress * Math.PI) * -30;
    ctx.fillStyle = a.color;
    ctx.globalAlpha = 1 - a.progress;
    if(a.type === 'magic') {
      ctx.beginPath();
      ctx.arc(cx - cam.x, cy - cam.y, 8 - a.progress*6, 0, Math.PI*2);
      ctx.fill();
      // Trail
      for(let i = 0; i < 3; i++) {
        ctx.globalAlpha = (1 - a.progress) * 0.3;
        ctx.beginPath();
        ctx.arc(cx - cam.x - (a.tx-a.x)*0.05*i, cy - cam.y + i*2, 4, 0, Math.PI*2);
        ctx.fill();
      }
    } else if(a.type === 'ranged') {
      ctx.fillRect(cx - cam.x - 6, cy - cam.y - 1, 12, 2);
    } else {
      // Melee slash arc
      ctx.strokeStyle = a.color;
      ctx.lineWidth = 3;
      ctx.globalAlpha = 1 - a.progress;
      ctx.beginPath();
      ctx.arc(cx - cam.x, cy - cam.y, 15, -Math.PI*a.progress, Math.PI*(1-a.progress));
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  });

  // Player
  const pColors = {
    body: player.combat_class==='melee'?'#8a3333':player.combat_class==='ranged'?'#33883a':'#335588',
    hat: player.combat_class==='melee'?'#6a2222':player.combat_class==='ranged'?'#226622':'#223366',
    skin: '#c8a882',
    legs: '#2a2a4a',
    arms: player.combat_class==='melee'?'#7a3333':player.combat_class==='ranged'?'#33773a':'#334477',
  };
  drawCharacter(player.x, player.y, player.facing, player.walkTimer, pColors, 24, 40, player.equipment);

  // Player name
  if(player.agent_id) {
    drawText(player.agent_id, player.x, player.y - 55, '#33cc33', 10);
  }

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = Math.max(0, p.life);
    if(p.type === 'hitsplat') {
      // RuneScape-style hitsplat
      const px = p.x - cam.x;
      const py = p.y - cam.y;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.ellipse(px, py, 16, 12, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(p.text, px, py + 4);
    } else if(p.type === 'text') {
      ctx.fillStyle = p.color;
      ctx.font = 'bold 16px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(p.text, p.x - cam.x, p.y - cam.y);
    } else {
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - cam.x - p.size/2, p.y - cam.y - p.size/2, p.size, p.size);
    }
    ctx.globalAlpha = 1;
  });

  // ‚îÄ‚îÄ‚îÄ HUD ‚îÄ‚îÄ‚îÄ
  renderHUD();
  renderMinimap();
  renderCombatLog();
}

function renderHUD() {
  hpCtx.clearRect(0, 0, 200, 80);

  // HP bar
  hpCtx.fillStyle = 'rgba(0,0,0,0.7)';
  hpCtx.fillRect(0, 0, 200, 80);
  hpCtx.strokeStyle = '#d4a017';
  hpCtx.lineWidth = 1;
  hpCtx.strokeRect(0, 0, 200, 80);

  // HP
  hpCtx.fillStyle = '#888';
  hpCtx.font = '10px Courier New';
  hpCtx.textAlign = 'left';
  hpCtx.fillText('Hitpoints', 10, 16);
  hpCtx.fillStyle = '#222';
  hpCtx.fillRect(10, 20, 180, 14);
  const hpPct = player.hp / player.maxHp;
  hpCtx.fillStyle = hpPct > 0.3 ? '#33cc33' : '#cc3333';
  hpCtx.fillRect(10, 20, 180 * hpPct, 14);
  hpCtx.fillStyle = '#fff';
  hpCtx.font = 'bold 10px Courier New';
  hpCtx.textAlign = 'center';
  hpCtx.fillText(`${player.hp} / ${player.maxHp}`, 100, 32);

  // Prayer
  hpCtx.fillStyle = '#888';
  hpCtx.font = '10px Courier New';
  hpCtx.textAlign = 'left';
  hpCtx.fillText('Prayer', 10, 50);
  hpCtx.fillStyle = '#222';
  hpCtx.fillRect(10, 54, 180, 14);
  const prayPct = player.prayer / player.maxPrayer;
  hpCtx.fillStyle = '#3388cc';
  hpCtx.fillRect(10, 54, 180 * prayPct, 14);
  hpCtx.fillStyle = '#fff';
  hpCtx.font = 'bold 10px Courier New';
  hpCtx.textAlign = 'center';
  hpCtx.fillText(`${player.prayer} / ${player.maxPrayer}`, 100, 66);
}

function renderMinimap() {
  minimapCtx.clearRect(0, 0, 180, 60);
  minimapCtx.fillStyle = 'rgba(0,0,0,0.8)';
  minimapCtx.fillRect(0, 0, 180, 60);

  const areaWidth = getAreaWidth();
  const scale = 180 / areaWidth;
  const zones = getAreaZones();

  // Zone colors on minimap
  zones.forEach(z => {
    minimapCtx.fillStyle = z.ground;
    minimapCtx.fillRect(z.x * scale, 40, z.w * scale, 20);
  });

  // Zone labels
  minimapCtx.fillStyle = '#888';
  minimapCtx.font = '7px Courier New';
  minimapCtx.textAlign = 'center';
  zones.forEach(z => {
    minimapCtx.fillText(z.name.split(' ')[0], (z.x + z.w/2) * scale, 12);
  });

  // NPCs
  npcs.forEach(n => {
    if((n.area_id || DEFAULT_AREA_ID) !== (player.area_id || DEFAULT_AREA_ID)) return;
    minimapCtx.fillStyle = '#d4a017';
    minimapCtx.fillRect(n.x * scale - 1, 35, 2, 4);
  });

  // Connected agents
  worldAgents.forEach(agent => {
    minimapCtx.fillStyle = '#66d4ff';
    minimapCtx.fillRect(agent.x * scale - 1, 36, 2, 4);
  });

  // Player
  minimapCtx.fillStyle = '#33ff33';
  minimapCtx.fillRect(player.x * scale - 2, 32, 4, 6);

  // Viewport
  minimapCtx.strokeStyle = '#d4a017';
  minimapCtx.lineWidth = 1;
  minimapCtx.strokeRect(cam.x * scale, 20, W * scale, 30);
}

function renderCombatLog() {
  if(!player.inFight || combatLog.length === 0) return;

  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(10, H - 200, 380, 180);
  ctx.strokeStyle = '#d4a017';
  ctx.lineWidth = 1;
  ctx.strokeRect(10, H - 200, 380, 180);

  ctx.fillStyle = '#d4a017';
  ctx.font = 'bold 11px Courier New';
  ctx.textAlign = 'left';
  ctx.fillText('‚öî Combat Log', 20, H - 183);

  ctx.font = '10px Courier New';
  const visible = combatLog.slice(-7);
  visible.forEach((line, i) => {
    ctx.fillStyle = line.includes('VICTORY') || line.includes('won') ? '#d4a017'
                  : line.includes('DEFEAT') || line.includes('lost') ? '#cc3333'
                  : line.startsWith('---') ? '#888' : '#ccc';
    ctx.fillText(line.slice(0, 55), 20, H - 165 + i * 18);
  });

  // Round score
  if(arenaFight) {
    ctx.fillStyle = '#d4a017';
    ctx.font = 'bold 12px Courier New';
    ctx.textAlign = 'right';
    ctx.fillText(`Round ${arenaFight.round} | You ${arenaFight.roundsWon.p1} - ${arenaFight.roundsWon.p2} Opponent`, 380, H - 183);
    ctx.fillText(`Tick ${arenaFight.tick}`, 380, H - 168);
  }
}

// ‚îÄ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ‚îÄ
function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

window.render_game_to_text = function renderGameToText() {
  const visibleAgents = [];
  worldAgents.forEach((agent) => {
    visibleAgents.push({
      id: agent.agent_id,
      class: agent.combat_class,
      x: agent.x,
      y: agent.y,
      zone: agent.zone,
    });
  });

  const visibleNodes = [];
  resourceNodes.forEach((node) => {
    if(Math.abs(node.x - player.x) < 800) {
      visibleNodes.push({
        id: node.node_id,
        type: node.type,
        skill: node.skill,
        level_required: node.level_required,
        depleted: !!(node.depleted_until && node.depleted_until > Date.now()),
      });
    }
  });

  const payload = {
    coordinate_system: 'origin top-left, +x right, +y down',
    mode: player.inFight ? 'duel_arena' : 'open_world',
    player: {
      id: player.agent_id,
      class: player.combat_class,
      x: Math.round(player.x),
      y: Math.round(player.y),
      hp: player.hp,
      prayer: player.prayer,
      zone: currentZone?.name || null,
      area_id: player.area_id || DEFAULT_AREA_ID,
      instance_id: player.instance_id || null,
      registered: player.registered,
      queued_for_duel: queuedForDuel,
      active_skill_node: skillActionNodeId,
    },
    duel: arenaFight ? {
      fight_id: arenaFight.fight_id,
      round: arenaFight.round,
      tick: arenaFight.tick,
      score: arenaFight.roundsWon,
      opponent: {
        id: arenaFight.opponent.id,
        class: arenaFight.opponent.class,
        hp: arenaFight.opponent.hp,
        prayer: arenaFight.opponent.prayer,
      },
      recent_log: combatLog.slice(-4),
    } : null,
    open_world_agents: visibleAgents,
    resource_nodes: visibleNodes,
  };

  return JSON.stringify(payload);
};

window.advanceTime = (ms = 16) => {
  const frameMs = 1000 / 60;
  const steps = Math.max(1, Math.round(ms / frameMs));
  for(let i = 0; i < steps; i++) {
    update();
  }
  render();
};

fetchResourceNodes();
gameLoop();

// ‚îÄ‚îÄ‚îÄ PREVENT SCROLL ‚îÄ‚îÄ‚îÄ
addEventListener('keydown', e => { if([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Tab'].includes(e.key)) e.preventDefault(); });
</script>
</body>
</html>
