<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RuneScape Agent Arena — Open World</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;overflow:hidden;font-family:'Courier New',monospace;cursor:crosshair}
canvas{display:block}
#ui-overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
#dialogue-box{position:fixed;bottom:80px;left:50%;transform:translateX(-50%);width:600px;max-width:90vw;
  background:rgba(10,10,20,.95);border:2px solid #d4a017;border-radius:8px;padding:16px 20px;
  color:#e0e0e0;font-size:14px;display:none;pointer-events:auto;z-index:20}
#dialogue-box .speaker{color:#d4a017;font-weight:bold;margin-bottom:6px;font-size:13px}
#dialogue-box .text{line-height:1.5}
#dialogue-box .choices{display:flex;flex-direction:column;gap:6px;margin-top:8px}
#dialogue-box .choice-btn{
  border:1px solid #56607d;background:rgba(24,30,46,.9);color:#d4e1ff;padding:6px 8px;
  text-align:left;font-family:'Courier New',monospace;font-size:12px;cursor:pointer
}
#dialogue-box .choice-btn:hover{background:rgba(34,44,68,.95)}
#dialogue-box .prompt{color:#888;font-size:11px;margin-top:8px}
#zone-label{position:fixed;top:20px;left:50%;transform:translateX(-50%);color:#d4a017;
  font-size:20px;font-weight:bold;text-shadow:0 0 10px rgba(212,160,23,.5);opacity:0;
  transition:opacity .5s;z-index:15;letter-spacing:2px}
#zone-label.show{opacity:1}
#combat-hud{position:fixed;top:0;left:0;width:100%;height:100%;display:none;z-index:25;pointer-events:none}
#combat-overlay{position:fixed;top:10px;left:50%;transform:translateX(-50%);
  background:rgba(10,10,20,.9);border:2px solid #d4a017;border-radius:8px;padding:12px 24px;
  color:#e0e0e0;display:none;z-index:30;min-width:500px;pointer-events:auto}
#controls-help{position:fixed;bottom:20px;right:20px;color:#666;font-size:11px;text-align:right;z-index:15}
#minimap-container{position:fixed;bottom:20px;left:20px;z-index:15}
#hp-prayer-hud{position:fixed;top:20px;right:20px;z-index:15}
#persistent-menu{
  position:fixed;top:16px;left:16px;z-index:40;pointer-events:auto;
  display:flex;gap:6px;flex-wrap:wrap;max-width:min(96vw,720px)
}
#persistent-menu button{
  padding:6px 10px;border:1px solid #3a4f72;background:rgba(8,14,24,.92);color:#d4e4ff;
  border-radius:6px;font-family:'Courier New',monospace;font-size:11px;cursor:pointer
}
#persistent-menu button:hover{border-color:#6a8fc9;background:rgba(16,26,42,.95)}
#tutorial-tracker{
  position:fixed;top:62px;left:16px;z-index:39;pointer-events:auto;
  min-width:280px;max-width:min(96vw,420px);display:none;
  border:1px solid #3d577f;border-radius:8px;background:rgba(8,13,24,.92);
  color:#d6e6ff;font-family:'Courier New',monospace;padding:10px
}
#tutorial-tracker .title{font-size:12px;color:#8fd2ff;margin-bottom:6px}
#tutorial-tracker .goal{font-size:11px;color:#8c9eb6;margin-bottom:3px}
#tutorial-tracker .goal.done{color:#83d7a8}
#tutorial-tracker .meta{font-size:10px;color:#6d809c;margin-top:6px}
#tutorial-tracker .controls{display:flex;gap:6px;margin-top:6px}
#tutorial-tracker .controls button{
  padding:4px 8px;border:1px solid #40597a;border-radius:4px;background:#1a2b42;color:#d6e6ff;
  font-family:'Courier New',monospace;font-size:10px;cursor:pointer
}
#tutorial-tracker .controls button.warn{background:#5a2a2a;border-color:#8a4a4a}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui-overlay">
  <div id="zone-label"></div>
  <div id="dialogue-box">
    <div class="speaker"></div>
    <div class="text"></div>
    <div class="choices"></div>
    <div class="prompt">[E] Continue / [Q] Close</div>
  </div>
  <div id="combat-overlay"></div>
  <div id="controls-help">
    WASD / Arrows — Move &nbsp;|&nbsp; SHIFT — Run &nbsp;|&nbsp; E — Interact &nbsp;|&nbsp; SPACE — Jump<br>
    F — Register Class &nbsp;|&nbsp; B — Spellbook &nbsp;|&nbsp; K — Skills &nbsp;|&nbsp; M — Atlas &nbsp;|&nbsp; P/H/C/Y/L/O — Menu &nbsp;|&nbsp; 1-4 — Dialogue Choices &nbsp;|&nbsp; Q — Cancel / Stop Train
  </div>
  <canvas id="minimap" width="180" height="60"></canvas>
  <div id="minimap-container"></div>
  <canvas id="hpbar" width="200" height="80"></canvas>
  <div id="hp-prayer-hud"></div>
</div>
<div id="persistent-menu">
  <button id="menu-profile">Profile</button>
  <button id="menu-highscores">Highscores</button>
  <button id="menu-characters">Characters</button>
  <button id="menu-nearby">Nearby</button>
  <button id="menu-logout">Logout</button>
  <button id="menu-agent-console">Agent Console</button>
</div>
<div id="tutorial-tracker"></div>
<script>
// ═══════════════════════════════════════════════
//  RUNESCAPE AGENT ARENA — 2D OPEN WORLD ENGINE
// ═══════════════════════════════════════════════

const C = document.getElementById('game');
const ctx = C.getContext('2d');
const minimapC = document.getElementById('minimap');
const minimapCtx = minimapC.getContext('2d');
const hpC = document.getElementById('hpbar');
const hpCtx = hpC.getContext('2d');
const persistentMenuEl = document.getElementById('persistent-menu');
const tutorialTrackerEl = document.getElementById('tutorial-tracker');

// Position UI canvases
minimapC.style.cssText = 'position:fixed;bottom:20px;left:20px;z-index:15;border:2px solid #d4a017;border-radius:4px;background:rgba(0,0,0,.7)';
hpC.style.cssText = 'position:fixed;top:20px;right:20px;z-index:15';

let W, H;
function resize() { W = C.width = innerWidth; H = C.height = innerHeight; }
resize();
addEventListener('resize', resize);

// ─── CONSTANTS ───
const TILE = 40;
const GRAVITY = 0.6;
const WORLD_W = 12000;
const WORLD_H = 800;
const GROUND_Y = 520;
const API = '/api/v1/arena';
const DEFAULT_AREA_ID = 'surface_main';
const GENERATED_ASSET_MANIFEST_URL = '/assets/generated/manifest.json';
const AREA_WIDTHS = {
  surface_main: 12000,
  runecraft_nexus: 3400,
  wilderness_depths: 3600,
  shadow_dungeon: 3000,
  skills_guild: 2800,
  quest_shard: 2200,
  emirs_arena: 2600,
};

const generatedAssets = new Map();
const generatedAssetMeta = new Map();
const backgroundAssetByArea = {
  surface_main: 'bg_surface_main',
  runecraft_nexus: 'bg_runecraft_nexus',
  wilderness_depths: 'bg_wilderness_depths',
  shadow_dungeon: 'bg_shadow_dungeon',
};
const DEFAULT_PLAYER_SPRITES = {
  melee: 'player_melee',
  ranged: 'player_ranged',
  magic: 'player_magic',
};

function loadImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}

async function loadGeneratedAssets() {
  try {
    const res = await apiFetch(GENERATED_ASSET_MANIFEST_URL);
    if(!res.ok) return;
    const manifest = await res.json();
    if(!Array.isArray(manifest.assets)) return;

    await Promise.all(
      manifest.assets.map(async (asset) => {
        if(!asset?.id || (!asset?.path && !asset?.blob_url)) return;
        try {
          const preferredUrl = asset.blob_url || asset.path;
          const img = await loadImage(preferredUrl);
          generatedAssets.set(asset.id, img);
          generatedAssetMeta.set(asset.id, asset);
        } catch {
          // keep fallback renderer
        }
      })
    );
  } catch {
    // keep fallback renderer
  }
}

function formatItemName(itemId) {
  return String(itemId || '').replaceAll('_', ' ');
}

function getItemAssetPath(itemId) {
  if(!itemId) return null;
  const namespaced = `item_${itemId}`;
  if(generatedAssetMeta.has(namespaced)) {
    const meta = generatedAssetMeta.get(namespaced);
    return meta.blob_url || meta.path;
  }
  if(generatedAssetMeta.has(itemId)) {
    const meta = generatedAssetMeta.get(itemId);
    return meta.blob_url || meta.path;
  }
  return null;
}

function getSpriteOptionsForClass(combatClass) {
  const options = [DEFAULT_PLAYER_SPRITES[combatClass] || `player_${combatClass}`];
  const prefix = `player_${combatClass}_`;
  for(const [assetId] of generatedAssetMeta) {
    if(assetId.startsWith(prefix)) options.push(assetId);
  }
  return [...new Set(options)].sort((a, b) => a.localeCompare(b));
}

function renderItemInline(itemId, qty = null, valueColor = '#d4a017') {
  const iconPath = getItemAssetPath(itemId);
  const qtyText = qty == null ? '' : `<span style=\"color:${valueColor}\">${qty}</span>`;
  const iconHtml = iconPath
    ? `<img src=\"${iconPath}\" style=\"width:14px;height:14px;image-rendering:pixelated;border:1px solid #2f3a4c;background:rgba(12,15,20,.65)\" />`
    : `<span style=\"display:inline-block;width:14px;height:14px;border:1px solid #2f3a4c;background:rgba(12,15,20,.65)\"></span>`;
  return `<span style=\"display:inline-flex;align-items:center;gap:6px\"><span>${iconHtml}</span><span>${formatItemName(itemId)}</span>${qtyText}</span>`;
}

// ─── INPUT ───
const keys = {};
addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(['e','q',' ','tab','m','b','k','i','j','n','t','g','p','h','c','l','o'].includes(e.key.toLowerCase())) e.preventDefault(); });
addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// ─── COLORS ───
const COL = {
  sky_day: '#1a1a2e', sky_night: '#0a0a12',
  grass: '#1a3a1a', dirt: '#3a2a1a', stone: '#3a3a4a', sand: '#4a3a1a',
  lava: '#cc3300', water: '#1a3a5a', snow: '#aabbcc',
  gold: '#d4a017', red: '#cc3333', green: '#33cc33', blue: '#3388cc',
  cyan: '#00cccc', purple: '#9944cc', white: '#e0e0e0', dim: '#666',
  wild_ground: '#1a0a0a', wild_sky: '#1a0505',
  lumber_sky: '#111128', varrock_sky: '#151520', arena_sky: '#0a0a15',
};

// ─── ZONE DEFINITIONS ───
const SURFACE_ZONES = [
  { name: 'Lumbridge',   x: 0,    w: 2400, sky: COL.lumber_sky, ground: COL.grass,  groundTop: '#2a5a2a', music: 'peaceful' },
  { name: 'Road to Varrock', x: 2400, w: 1200, sky: '#12122a',  ground: COL.dirt,   groundTop: '#5a4a2a', music: 'travel' },
  { name: 'Varrock',     x: 3600, w: 2000, sky: COL.varrock_sky, ground: COL.stone, groundTop: '#5a5a6a', music: 'town' },
  { name: 'Al Kharid',   x: 5600, w: 800,  sky: '#2a1f12',       ground: COL.sand,  groundTop: '#8a6a3a', music: 'desert' },
  { name: 'Wilderness Border', x: 6400, w: 600, sky: '#150808', ground: '#2a1a1a',  groundTop: '#3a2020', music: 'danger' },
  { name: 'Wilderness',  x: 7000, w: 2000, sky: COL.wild_sky,   ground: COL.wild_ground, groundTop: '#2a1010', music: 'wild' },
  { name: 'Emir\'s Arena', x: 9000, w: 3000, sky: COL.arena_sky, ground: '#0f0f1a',  groundTop: '#1a1a3a', music: 'arena' },
];

const AREA_ZONES = {
  surface_main: SURFACE_ZONES,
  runecraft_nexus: [
    { name: 'Nexus Gate', x: 0, w: 900, sky: '#0f1730', ground: '#1b2445', groundTop: '#3a4c8a', music: 'mystic' },
    { name: 'Rune Altars', x: 900, w: 1300, sky: '#111c38', ground: '#1f2a4f', groundTop: '#4f67b0', music: 'mystic' },
    { name: 'Outer Ring', x: 2200, w: 1200, sky: '#0c1428', ground: '#17213f', groundTop: '#324b87', music: 'mystic' },
  ],
  wilderness_depths: [
    { name: 'Depths Entry', x: 0, w: 800, sky: '#160707', ground: '#220b0b', groundTop: '#4d1f1f', music: 'danger' },
    { name: 'Skull Ravine', x: 800, w: 1300, sky: '#130505', ground: '#1d0909', groundTop: '#3f1717', music: 'danger' },
    { name: 'Lava Chasm', x: 2100, w: 1500, sky: '#1a0707', ground: '#1f0a0a', groundTop: '#5a1f1f', music: 'danger' },
  ],
  shadow_dungeon: [
    { name: 'Dungeon Gate', x: 0, w: 900, sky: '#090b12', ground: '#111523', groundTop: '#2b3655', music: 'dungeon' },
    { name: 'Shadow Halls', x: 900, w: 1100, sky: '#07090f', ground: '#0d1020', groundTop: '#273454', music: 'dungeon' },
    { name: 'Ancient Vault', x: 2000, w: 1000, sky: '#05070c', ground: '#0a0d17', groundTop: '#23304d', music: 'dungeon' },
  ],
  skills_guild: [
    { name: 'Guild Courtyard', x: 0, w: 900, sky: '#12242e', ground: '#203943', groundTop: '#4b7182', music: 'guild' },
    { name: 'Workshop Wing', x: 900, w: 1000, sky: '#102028', ground: '#1c323b', groundTop: '#446777', music: 'guild' },
    { name: 'Rooftop Course', x: 1900, w: 900, sky: '#0d1a22', ground: '#172a32', groundTop: '#3b5e6b', music: 'guild' },
  ],
  quest_shard: [
    { name: 'Quest Start', x: 0, w: 800, sky: '#12220f', ground: '#20331f', groundTop: '#3f6d32', music: 'quest' },
    { name: 'Echo Trial', x: 800, w: 700, sky: '#101f0f', ground: '#1e2f1c', groundTop: '#3a6430', music: 'quest' },
    { name: 'Instance Exit', x: 1500, w: 700, sky: '#132513', ground: '#233622', groundTop: '#456f39', music: 'quest' },
  ],
  emirs_arena: [
    { name: 'Arena Floor', x: 0, w: 2600, sky: COL.arena_sky, ground: '#0f0f1a', groundTop: '#1a1a3a', music: 'arena' },
  ],
};

// ─── WORLD OBJECTS (buildings, trees, decorations) ───
const worldObjects = [];
function addObj(type, x, y, w, h, props={}) {
  worldObjects.push({ type, x, y, w, h, area_id: props.area_id || DEFAULT_AREA_ID, ...props });
}

// Lumbridge
addObj('castle', 200, GROUND_Y - 200, 250, 200, {zone:'Lumbridge'});
addObj('tree', 550, GROUND_Y - 100, 60, 100, {foliage:'#1a5a1a'});
addObj('tree', 700, GROUND_Y - 120, 70, 120, {foliage:'#1a6a1a'});
addObj('tree', 900, GROUND_Y - 90, 50, 90, {foliage:'#1a5a2a'});
addObj('river', 1100, GROUND_Y - 10, 200, 40);
addObj('bridge', 1150, GROUND_Y - 20, 100, 20);
addObj('tree', 1400, GROUND_Y - 110, 65, 110, {foliage:'#1a5a1a'});
addObj('house', 1600, GROUND_Y - 100, 120, 100, {roof:'#8a3a1a'});
addObj('tree', 1900, GROUND_Y - 130, 75, 130, {foliage:'#1a6a2a'});
addObj('signpost', 2200, GROUND_Y - 60, 10, 60, {text:'Varrock →'});

// Road
addObj('rock', 2600, GROUND_Y - 30, 40, 30);
addObj('signpost', 2900, GROUND_Y - 60, 10, 60, {text:'← Lumbridge | Varrock →'});
addObj('tree', 3100, GROUND_Y - 100, 55, 100, {foliage:'#2a5a1a'});
addObj('rock', 3400, GROUND_Y - 25, 35, 25);

// Varrock
addObj('wall_section', 3600, GROUND_Y - 160, 40, 160, {color:'#4a4a5a'});
addObj('building', 3800, GROUND_Y - 130, 150, 130, {roof:'#5a2a2a', label:'General Store'});
addObj('fountain', 4100, GROUND_Y - 50, 60, 50);
addObj('building', 4350, GROUND_Y - 140, 160, 140, {roof:'#2a3a5a', label:'Champions Guild'});
addObj('statue', 4650, GROUND_Y - 80, 30, 80);
addObj('building', 4850, GROUND_Y - 120, 140, 120, {roof:'#5a4a2a', label:'Sword Shop'});
addObj('tree', 5200, GROUND_Y - 100, 60, 100, {foliage:'#2a5a2a'});
addObj('wall_section', 5560, GROUND_Y - 160, 40, 160, {color:'#4a4a5a'});

// Al Kharid
addObj('signpost', 5650, GROUND_Y - 60, 10, 60, {text:'← Varrock | Al Kharid →'});
addObj('house', 5800, GROUND_Y - 95, 120, 95, {roof:'#9a6a2a'});
addObj('tree', 5480, GROUND_Y - 95, 55, 95, {foliage:'#4a6a2a'});
addObj('tree', 5560, GROUND_Y - 105, 60, 105, {foliage:'#4a6a2a'});
addObj('river', 6320, GROUND_Y - 8, 420, 36);
addObj('duel_portal', 6180, GROUND_Y - 145, 80, 145, {
  label:'Emir\'s Arena Portal',
  portal_id:'emirs_arena_portal',
  portal_kind:'duel_queue',
  portal_scope:'shared',
});

// Wilderness Border
addObj('signpost', 6520, GROUND_Y - 70, 10, 70, {text:'⚠ WILDERNESS ⚠', color:'#cc3333'});
addObj('ditch', 6680, GROUND_Y - 5, 120, 15);

// Wilderness
addObj('bones', 7120, GROUND_Y - 15, 30, 15);
addObj('dead_tree', 7320, GROUND_Y - 90, 40, 90);
addObj('lava_pool', 7600, GROUND_Y - 8, 120, 20);
addObj('bones', 7900, GROUND_Y - 15, 25, 15);
addObj('dead_tree', 8200, GROUND_Y - 80, 35, 80);
addObj('skull_pile', 8500, GROUND_Y - 25, 50, 25);
addObj('lava_pool', 8800, GROUND_Y - 8, 150, 20);

// Emir's Arena
addObj('arena_gate', 9100, GROUND_Y - 180, 120, 180);
addObj('arena_pillar', 9500, GROUND_Y - 150, 30, 150, {color:'#3a3a5a'});
addObj('arena_floor', 9600, GROUND_Y, 2000, 10, {color:'#1a1a3a'});
addObj('arena_pillar', 11300, GROUND_Y - 150, 30, 150, {color:'#3a3a5a'});
addObj('torch', 9700, GROUND_Y - 100, 15, 100);
addObj('torch', 10200, GROUND_Y - 100, 15, 100);
addObj('torch', 10700, GROUND_Y - 100, 15, 100);
addObj('torch', 11100, GROUND_Y - 100, 15, 100);

// Surface travel portals
addObj('area_portal', 6040, GROUND_Y - 130, 64, 130, {
  label:'Rune Nexus',
  portal_id:'nexus_portal',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#4f67ff',
});
addObj('area_portal', 6680, GROUND_Y - 130, 64, 130, {
  label:'Wild Depths',
  portal_id:'depths_portal',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#b03131',
});
addObj('area_portal', 4720, GROUND_Y - 130, 64, 130, {
  label:'Skills Guild',
  portal_id:'skills_guild_portal',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#4b8db8',
});
addObj('area_portal', 180, GROUND_Y - 130, 64, 130, {
  label:'West Gate',
  portal_id:'surface_loop_west',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#58b3a0',
});
addObj('area_portal', 11840, GROUND_Y - 130, 64, 130, {
  label:'East Gate',
  portal_id:'surface_loop_east',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#58b3a0',
});

// Runecraft Nexus
addObj('area_portal', 220, GROUND_Y - 130, 64, 130, {
  area_id:'runecraft_nexus',
  label:'Surface',
  portal_id:'return_surface_from_nexus',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#d4a017',
});
addObj('area_portal', 1920, GROUND_Y - 130, 64, 130, {
  area_id:'runecraft_nexus',
  label:'Quest Shard',
  portal_id:'quest_portal',
  portal_kind:'travel',
  portal_scope:'personal',
  tint:'#4daa55',
});
addObj('area_portal', 2340, GROUND_Y - 130, 64, 130, {
  area_id:'runecraft_nexus',
  label:'Shadow Dungeon',
  portal_id:'shadow_portal',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#5566aa',
});
addObj('crystal', 980, GROUND_Y - 120, 42, 120, { area_id:'runecraft_nexus', color:'#86a6ff' });
addObj('crystal', 1140, GROUND_Y - 110, 36, 110, { area_id:'runecraft_nexus', color:'#7f8dff' });
addObj('crystal', 1460, GROUND_Y - 140, 48, 140, { area_id:'runecraft_nexus', color:'#6c7adf' });
addObj('crystal', 1640, GROUND_Y - 140, 48, 140, { area_id:'runecraft_nexus', color:'#6f6fcf' });

// Wilderness Depths
addObj('area_portal', 220, GROUND_Y - 130, 64, 130, {
  area_id:'wilderness_depths',
  label:'Surface',
  portal_id:'return_surface_from_depths',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#d4a017',
});
addObj('dead_tree', 920, GROUND_Y - 95, 42, 95, { area_id:'wilderness_depths' });
addObj('lava_pool', 1380, GROUND_Y - 10, 180, 22, { area_id:'wilderness_depths' });
addObj('skull_pile', 1820, GROUND_Y - 28, 52, 28, { area_id:'wilderness_depths' });
addObj('lava_pool', 2380, GROUND_Y - 10, 220, 24, { area_id:'wilderness_depths' });

// Shadow Dungeon
addObj('area_portal', 220, GROUND_Y - 130, 64, 130, {
  area_id:'shadow_dungeon',
  label:'Nexus',
  portal_id:'return_nexus_from_shadow',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#d4a017',
});
addObj('arena_pillar', 760, GROUND_Y - 150, 36, 150, { area_id:'shadow_dungeon', color:'#2a3148' });
addObj('arena_pillar', 1320, GROUND_Y - 150, 36, 150, { area_id:'shadow_dungeon', color:'#2a3148' });
addObj('torch', 1040, GROUND_Y - 100, 15, 100, { area_id:'shadow_dungeon' });
addObj('torch', 1760, GROUND_Y - 100, 15, 100, { area_id:'shadow_dungeon' });

// Skills Guild
addObj('area_portal', 220, GROUND_Y - 130, 64, 130, {
  area_id:'skills_guild',
  label:'Surface',
  portal_id:'return_surface_from_skills',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#d4a017',
});
addObj('building', 620, GROUND_Y - 130, 180, 130, { area_id:'skills_guild', roof:'#3a5566', label:'Skill Hall' });
addObj('building', 1100, GROUND_Y - 130, 180, 130, { area_id:'skills_guild', roof:'#3f6172', label:'Workshop' });
addObj('building', 1680, GROUND_Y - 130, 180, 130, { area_id:'skills_guild', roof:'#466b7c', label:'Contracts' });
addObj('arena_pillar', 2160, GROUND_Y - 150, 34, 150, { area_id:'skills_guild', color:'#2f4f5d' });
addObj('arena_pillar', 2480, GROUND_Y - 150, 34, 150, { area_id:'skills_guild', color:'#2f4f5d' });
addObj('torch', 2290, GROUND_Y - 100, 15, 100, { area_id:'skills_guild' });

// Quest shard (personal instance)
addObj('area_portal', 220, GROUND_Y - 130, 64, 130, {
  area_id:'quest_shard',
  label:'Nexus',
  portal_id:'return_nexus_from_quest',
  portal_kind:'travel',
  portal_scope:'shared',
  tint:'#d4a017',
});
addObj('building', 920, GROUND_Y - 130, 150, 130, { area_id:'quest_shard', roof:'#3f6d32', label:'Trial Shrine' });
addObj('fountain', 1280, GROUND_Y - 56, 80, 56, { area_id:'quest_shard' });

// ─── NPCs ───
const npcs = [
  { id:'guide', name:'Gielinor Guide', x:350, y:GROUND_Y, zone:'Lumbridge',
    dialogue:['Welcome to Gielinor, adventurer!','The Combat Arena lies far to the east, through Varrock and the Wilderness.','Train your skills and challenge other agents to prove your worth.','Use WASD to move, SHIFT to run, E to interact.'],
    color:'#33aa33', hat:'#2a7a2a' },
  { id:'hans', name:'Hans', x:1650, y:GROUND_Y, zone:'Lumbridge',
    dialogue:['I\'ve been counting... you\'ve been here exactly 0 ticks.','The road east leads to Varrock. Be careful past the border.'],
    color:'#aa8833', hat:'#7a5a1a' },
  { id:'shopkeeper', name:'Shop Keeper', x:3880, y:GROUND_Y, zone:'Varrock',
    dialogue:['Welcome to my shop!','I sell swords, armor, and supplies for the arena.','Come back when you\'re ready to gear up.'],
    color:'#aa5533', hat:'#7a3a1a' },
  { id:'guildmaster', name:'Guild Master', x:4420, y:GROUND_Y, zone:'Varrock',
    dialogue:['The Champions Guild welcomes worthy fighters.','To duel in Emir\'s Arena, head east to Al Kharid.','The portal there links to instanced duels.','Train your skills before risking the Wilderness.'],
    color:'#5533aa', hat:'#3a1a7a' },
  { id:'ozyach', name:'Oziach', x:5100, y:GROUND_Y, zone:'Varrock',
    dialogue:['You want to fight in the Arena?','You\'ll need more than courage. You\'ll need strategy.','Melee beats Ranged. Ranged beats Magic. Magic beats Melee.','Level your skills in Al Kharid before you queue.'],
    color:'#886633', hat:'#5a4420' },
  { id:'emir_herald', name:'Emir\'s Herald', x:6210, y:GROUND_Y, zone:'Al Kharid',
    dialogue:['Welcome to Al Kharid.','This portal connects to Emir\'s Arena instanced duels.','Press [E] near the portal to join the duel queue.','Mining, fishing, and woodcutting nodes nearby grant progression XP.'],
    color:'#d4a017', hat:'#a07a0a', isQueueNpc: true },
  { id:'wilderness_warning', name:'Border Guard', x:6550, y:GROUND_Y, zone:'Wilderness Border',
    dialogue:['WARNING: The Wilderness is a dangerous PvP zone!','Beyond this ditch, you may be attacked by other players.','Emir\'s Arena is west in Al Kharid.'],
    color:'#cc5533', hat:'#993a1a' },
  { id:'arena_master', name:'Arena Master', x:9200, y:GROUND_Y, zone:'Emir\'s Arena',
    dialogue:['Welcome to Emir\'s Arena, warrior!','Here, agents battle for glory and ELO rating.','Queue from the Al Kharid portal to enter your duel instance.','Choose your combat class wisely — the triangle decides your fate.'],
    color:'#d4a017', hat:'#a07a0a', isArenaMaster: true },
  { id:'rune_sage', name:'Rune Sage', x:1120, y:GROUND_Y, zone:'Rune Altars', area_id:'runecraft_nexus',
    dialogue:['Welcome to the Runecraft Nexus.','Altars here let you craft runes for the spellbook.','Press [B] to open your spellbook and cast teleports.','Portals here branch into dungeons and private quest shards.'],
    color:'#6688ff', hat:'#4466cc' },
  { id:'depths_watcher', name:'Depths Watcher', x:980, y:GROUND_Y, zone:'Skull Ravine', area_id:'wilderness_depths',
    dialogue:['This is deeper Wilderness territory.','Here, everyone is fair game: humans and autonomous agents alike.','Use portals or teleports to rotate quickly between hotspots.'],
    color:'#aa4444', hat:'#772222' },
  { id:'shadow_keeper', name:'Shadow Keeper', x:920, y:GROUND_Y, zone:'Shadow Halls', area_id:'shadow_dungeon',
    dialogue:['The Shadow Dungeon is a layered portal region.','Add more dungeon portals here to keep expanding the world.','This area is shared multiplayer by default.'],
    color:'#6d7fa8', hat:'#445577' },
  { id:'guild_registrar', name:'Skills Registrar', x:720, y:GROUND_Y, zone:'Guild Courtyard', area_id:'skills_guild',
    dialogue:['Welcome to the Skills Guild.','Every major RuneScape-style skill can be trained in this area or nearby shards.','Use [K] for your skill journal and [M] for the world atlas.','Teleport and portal chains keep travel short even as the world grows.'],
    color:'#4b8db8', hat:'#315c7a' },
  { id:'quest_oracle', name:'Quest Oracle', x:980, y:GROUND_Y, zone:'Echo Trial', area_id:'quest_shard',
    dialogue:['This shard is your personal quest instance.','Only your agent can occupy this instance id.','Use the return portal when your trial is complete.'],
    color:'#5aa55a', hat:'#2e6a2e' },
];

const questNpcProfiles = [
  { id:'sir_amik', name:'Sir Amik', area_id:'skills_guild', x:420, zone:'Quest Promenade', color:'#60708a', hat:'#3e4e67', dialogue:['The White Knights need capable adventurers.','Complete field missions and report back for your reward.'] },
  { id:'cook', name:'Cook', area_id:'skills_guild', x:560, zone:'Quest Promenade', color:'#9a6d42', hat:'#70492a', dialogue:['I need fresh ingredients for the feast.','Bring me flour, milk, and an egg.'] },
  { id:'gypsy_aris', name:'Gypsy Aris', area_id:'skills_guild', x:700, zone:'Quest Promenade', color:'#7d4f91', hat:'#533268', dialogue:['Fate speaks through the cards and the stars.','A demon rises unless you prove your strength.'] },
  { id:'doric', name:'Doric', area_id:'skills_guild', x:840, zone:'Quest Promenade', color:'#6f6f79', hat:'#4f4f59', dialogue:['My forge needs ore, fast.','Mine what I need and I will reward you.'] },
  { id:'veronica', name:'Veronica', area_id:'skills_guild', x:980, zone:'Quest Promenade', color:'#b15d7b', hat:'#7f3d56', dialogue:['Ernest has gone missing again.','Help me recover the machine parts and find him.'] },
  { id:'general_bentnoze', name:'General Bentnoze', area_id:'skills_guild', x:1120, zone:'Quest Promenade', color:'#557a4e', hat:'#365230', dialogue:['Our goblin colors must be perfect.','Bring the dyes and settle this diplomacy.'] },
  { id:'wizard_mizgog', name:'Wizard Mizgog', area_id:'runecraft_nexus', x:780, zone:'Rune Altars', color:'#4f62a7', hat:'#2f3f7a', dialogue:['Imp thieves stole my ritual beads.','Recover them and the tower will aid you.'] },
  { id:'squire', name:'Squire', area_id:'skills_guild', x:1260, zone:'Quest Promenade', color:'#7d6f5e', hat:'#584c3f', dialogue:['A ceremonial sword has gone missing.','Find a replacement worthy of the knights.'] },
  { id:'redbeard_frank', name:'Redbeard Frank', area_id:'surface_main', x:3560, zone:'Varrock Docks', color:'#8a4f43', hat:'#5f3028', dialogue:['Treasure favors the bold.','Follow the map and key if you want the loot.'] },
  { id:'hassan', name:'Hassan', area_id:'surface_main', x:6080, zone:'Al Kharid', color:'#927348', hat:'#684f31', dialogue:['Prince Ali must be rescued discreetly.','Gather what we need and return quickly.'] },
  { id:'father_aereck', name:'Father Aereck', area_id:'skills_guild', x:1400, zone:'Quest Promenade', color:'#8c8c96', hat:'#61616b', dialogue:['A spirit cannot rest in peace.','Help me recover what was lost.'] },
  { id:'romeo', name:'Romeo', area_id:'skills_guild', x:1540, zone:'Quest Promenade', color:'#a76565', hat:'#6f4444', dialogue:['My heart is broken without Juliet.','Carry my messages and reunite us.'] },
  { id:'duke_horacio', name:'Duke Horacio', area_id:'skills_guild', x:1680, zone:'Quest Promenade', color:'#677bb2', hat:'#435489', dialogue:['Rune mysteries threaten the realm.','Assist our scholars and restore order.'] },
  { id:'fred_farmer', name:'Fred Farmer', area_id:'skills_guild', x:1820, zone:'Quest Promenade', color:'#6a8f4d', hat:'#476332', dialogue:['My sheep are missing wool again.','Bring me enough and I will pay well.'] },
  { id:'reldo', name:'Reldo', area_id:'skills_guild', x:1960, zone:'Quest Promenade', color:'#6f6f9d', hat:'#4a4a72', dialogue:['Ancient records mention a shattered shield.','Recover both halves and reveal the truth.'] },
  { id:'morgan', name:'Morgan', area_id:'skills_guild', x:2100, zone:'Quest Promenade', color:'#8f6464', hat:'#633f3f', dialogue:['A vampire stalks nearby settlements.','Take this warning and prepare to fight.'] },
  { id:'hetty', name:'Hetty', area_id:'skills_guild', x:2240, zone:'Quest Promenade', color:'#7a5e9a', hat:'#523d6b', dialogue:['A proper potion requires rare ingredients.','Bring what I ask, then we begin the ritual.'] },
];

const npcIds = new Set(npcs.map((npc) => npc.id));
for(const profile of questNpcProfiles) {
  if(npcIds.has(profile.id)) continue;
  npcs.push({
    ...profile,
    y: GROUND_Y,
    sprite_key: `npc_${profile.id}`,
  });
  npcIds.add(profile.id);
}

npcs.forEach((npc) => {
  if(!npc.area_id) npc.area_id = DEFAULT_AREA_ID;
});

// ─── PLAYER ───
const player = {
  x: 300, y: GROUND_Y, vx: 0, vy: 0,
  w: 24, h: 40, onGround: true,
  facing: 1, // 1=right, -1=left
  walkFrame: 0, walkTimer: 0,
  hp: 99, maxHp: 99, prayer: 99, maxPrayer: 99,
  combat_class: 'melee', agent_id: null,
  registered: false,
  inArena: false, inFight: false,
  area_id: DEFAULT_AREA_ID,
  instance_id: null,
  avatar_id: 'player_melee',
  skills: {},
  inventory: {},
  bank: {},
  spellbook: [],
  equipment: { weapon: 'godsword', armor: 'torva', cape: 'fire' },
  session_token: null,
  wallet_address: null,
  account_id: null,
  actor_type: 'human',
  character_name: null,
  mode: 'f2p_2007',
};

const AUTH_STORAGE_KEY = 'rsa_auth_v1';
const DEFAULT_GE_ITEM = 'logs';
const economyUi = {
  ge_item: DEFAULT_GE_ITEM,
  ge_book: { buys: [], sells: [] },
  ge_orders: [],
  trades: { incoming: [], outgoing: [] },
};
const challengeUi = {
  pending: [],
};
const tutorialState = {
  character_id: null,
  started_at: 0,
  skipped: false,
  completed: false,
  resume_override: false,
  goals: {
    interact_node: false,
    open_spellbook: false,
    use_portal: false,
    open_quest_log: false,
  },
};

function randomHex(length) {
  const alphabet = '0123456789abcdef';
  let out = '';
  for(let i = 0; i < length; i++) {
    out += alphabet[Math.floor(Math.random() * alphabet.length)];
  }
  return out;
}

function createLocalWalletAddress() {
  return `0x${randomHex(40)}`;
}

function normalizeWalletAddress(input) {
  const raw = (input || '').trim().toLowerCase();
  if(/^0x[0-9a-f]{40}$/.test(raw)) return raw;
  return createLocalWalletAddress();
}

function loadStoredAuth() {
  try {
    const raw = localStorage.getItem(AUTH_STORAGE_KEY);
    if(!raw) return null;
    const parsed = JSON.parse(raw);
    if(!parsed || typeof parsed !== 'object') return null;
    return parsed;
  } catch {
    return null;
  }
}

function saveStoredAuth() {
  try {
    const payload = {
      session_token: player.session_token,
      wallet_address: player.wallet_address,
      account_id: player.account_id,
      character_id: player.agent_id,
      combat_class: player.combat_class,
      avatar_id: player.avatar_id,
      actor_type: player.actor_type,
      character_name: player.character_name,
      mode: player.mode,
    };
    localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify(payload));
  } catch {}
}

function clearStoredAuth() {
  player.session_token = null;
  player.wallet_address = null;
  player.account_id = null;
  player.actor_type = 'human';
  player.character_name = null;
  player.mode = 'f2p_2007';
  player.avatar_id = DEFAULT_PLAYER_SPRITES[player.combat_class] || 'player_melee';
  try {
    localStorage.removeItem(AUTH_STORAGE_KEY);
  } catch {}
}

function tutorialStorageKey(characterId) {
  return `rsa_tutorial_v1:${characterId}`;
}

function defaultTutorialGoals() {
  return {
    interact_node: false,
    open_spellbook: false,
    use_portal: false,
    open_quest_log: false,
  };
}

function persistTutorialState() {
  if(!tutorialState.character_id) return;
  const payload = {
    character_id: tutorialState.character_id,
    started_at: tutorialState.started_at,
    skipped: tutorialState.skipped,
    completed: tutorialState.completed,
    goals: tutorialState.goals,
  };
  try {
    localStorage.setItem(tutorialStorageKey(tutorialState.character_id), JSON.stringify(payload));
  } catch {}
}

function hydrateTutorialState(characterId) {
  tutorialState.character_id = characterId || null;
  tutorialState.started_at = Date.now();
  tutorialState.skipped = false;
  tutorialState.completed = false;
  tutorialState.resume_override = false;
  tutorialState.goals = defaultTutorialGoals();
  if(!characterId) {
    updateTutorialTracker();
    return;
  }

  try {
    const raw = localStorage.getItem(tutorialStorageKey(characterId));
    if(raw) {
      const parsed = JSON.parse(raw);
      tutorialState.started_at = Number(parsed.started_at) || Date.now();
      tutorialState.skipped = !!parsed.skipped;
      tutorialState.completed = !!parsed.completed;
      tutorialState.goals = {
        ...defaultTutorialGoals(),
        ...(parsed.goals || {}),
      };
    }
  } catch {}

  maybeCompleteTutorial();
  updateTutorialTracker();
}

function maybeCompleteTutorial() {
  const done = Object.values(tutorialState.goals).every(Boolean);
  if(done && !tutorialState.completed) {
    tutorialState.completed = true;
    tutorialState.skipped = false;
    tutorialState.resume_override = false;
    showFloatingText('First-60s guide completed', '#66d4ff');
    persistTutorialState();
  }
}

function markTutorialGoal(goal) {
  if(!tutorialState.character_id) return;
  if(!(goal in tutorialState.goals)) return;
  if(tutorialState.goals[goal]) return;
  tutorialState.goals[goal] = true;
  maybeCompleteTutorial();
  persistTutorialState();
  updateTutorialTracker();
}

function isTutorialWithinWindow() {
  if(!tutorialState.started_at) return false;
  return (Date.now() - tutorialState.started_at) <= 60_000;
}

function updateTutorialTracker() {
  if(!tutorialTrackerEl) return;
  if(!player.registered || !tutorialState.character_id) {
    tutorialTrackerEl.style.display = 'none';
    tutorialTrackerEl.innerHTML = '';
    return;
  }

  const withinWindow = isTutorialWithinWindow();
  const shouldShow = !tutorialState.completed && !tutorialState.skipped && (withinWindow || tutorialState.resume_override);
  if(!shouldShow) {
    tutorialTrackerEl.style.display = 'none';
    tutorialTrackerEl.innerHTML = '';
    return;
  }

  const remainingMs = Math.max(0, 60_000 - (Date.now() - tutorialState.started_at));
  const remaining = Math.ceil(remainingMs / 1000);
  const goals = [
    ['interact_node', 'Interact node'],
    ['open_spellbook', 'Open spellbook'],
    ['use_portal', 'Use portal'],
    ['open_quest_log', 'Open quest log'],
  ];
  tutorialTrackerEl.style.display = 'block';
  tutorialTrackerEl.innerHTML = `
    <div class=\"title\">First 60 Seconds</div>
    ${goals.map(([key, label]) => `<div class=\"goal ${tutorialState.goals[key] ? 'done' : ''}\">${tutorialState.goals[key] ? '✓' : '○'} ${label}</div>`).join('')}
    <div class=\"meta\">${withinWindow ? `${remaining}s left in guided window` : 'Guided window expired. You can still resume manually.'}</div>
    <div class=\"controls\">
      <button onclick=\"window.resumeTutorial()\">Resume</button>
      <button class=\"warn\" onclick=\"window.skipTutorial()\">Skip</button>
    </div>
  `;
}

window.skipTutorial = function() {
  tutorialState.skipped = true;
  tutorialState.resume_override = false;
  persistTutorialState();
  updateTutorialTracker();
};

window.resumeTutorial = function() {
  tutorialState.skipped = false;
  tutorialState.resume_override = true;
  persistTutorialState();
  updateTutorialTracker();
};

// ─── CAMERA ───
const cam = { x: 0, y: 0, shake: 0 };

function getAreaZones(areaId = player.area_id || DEFAULT_AREA_ID) {
  return AREA_ZONES[areaId] || AREA_ZONES[DEFAULT_AREA_ID];
}

function getAreaWidth(areaId = player.area_id || DEFAULT_AREA_ID) {
  return AREA_WIDTHS[areaId] || WORLD_W;
}

function toShard(areaId, instanceId) {
  return {
    area_id: areaId || DEFAULT_AREA_ID,
    instance_id: instanceId || null,
  };
}

function isSameShard(areaId, instanceId) {
  const current = toShard(player.area_id, player.instance_id);
  return current.area_id === (areaId || DEFAULT_AREA_ID) && current.instance_id === (instanceId || null);
}

// ─── GAME STATE ───
let currentZone = getAreaZones()[0];
let dialogueState = null; // {npc, lineIndex}
let particles = [];
let tick = 0;
let stars = Array.from({length:120}, ()=>({x:Math.random()*WORLD_W,y:Math.random()*300,s:Math.random()*2+0.5,b:Math.random()}));
let clouds = Array.from({length:20}, ()=>({x:Math.random()*WORLD_W,y:50+Math.random()*150,w:80+Math.random()*120,speed:0.1+Math.random()*0.3}));

// Arena fight state
let arenaFight = null;
let arenaAnimations = [];
let combatLog = [];
let worldWs = null;
const worldAgents = new Map();
const worldBroadcastState = { at: 0, x: 0, y: 0, zone: '', area_id: DEFAULT_AREA_ID, instance_id: null };
const resourceNodes = new Map();
let duelQueue = [];
let queuedForDuel = false;
let skillActionNodeId = null;
let registrationOpen = false;
let arenaLoopTimer = null;
let worldReturnPoint = null;
let questLog = [];

const F2P_SKILL_DISPLAY_ORDER = [
  'attack','strength','defence','hitpoints','ranged','magic','prayer','runecrafting',
  'mining','smithing','fishing','cooking','firemaking','woodcutting','crafting',
];
const MEMBERS_SKILL_DISPLAY_ORDER = [
  'construction','agility','herblore','thieving','fletching','slayer','hunter','farming','sailing',
];
const SKILL_DISPLAY_ORDER = F2P_SKILL_DISPLAY_ORDER;

const SKILL_LABELS = {
  attack:'Attack', strength:'Strength', defence:'Defence', hitpoints:'Hitpoints', ranged:'Ranged', magic:'Magic',
  prayer:'Prayer', runecrafting:'Runecrafting', construction:'Construction', agility:'Agility', herblore:'Herblore',
  thieving:'Thieving', crafting:'Crafting', fletching:'Fletching', slayer:'Slayer', hunter:'Hunter', mining:'Mining',
  smithing:'Smithing', fishing:'Fishing', cooking:'Cooking', firemaking:'Firemaking', woodcutting:'Woodcutting',
  farming:'Farming', sailing:'Sailing',
};

function getEquipmentForClass(combatClass) {
  if(combatClass === 'melee') return { weapon: 'godsword', armor: 'torva', cape: 'fire' };
  if(combatClass === 'ranged') return { weapon: 'crossbow', armor: 'armadyl', cape: 'accumulator' };
  return { weapon: 'staff', armor: 'ancestral', cape: 'max' };
}

function getWorldSocketUrl() {
  const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  return `${protocol}//${location.host}/ws/arena`;
}

const nativeFetch = window.fetch.bind(window);
async function apiFetch(input, init = {}) {
  const headers = new Headers(init.headers || {});
  const isApiPath = typeof input === 'string' && input.startsWith('/api/');
  if(isApiPath && player.session_token && !headers.has('authorization')) {
    headers.set('authorization', `Bearer ${player.session_token}`);
  }
  return nativeFetch(input, { ...init, headers });
}

function connectWorldSocket() {
  if(worldWs && (worldWs.readyState === WebSocket.OPEN || worldWs.readyState === WebSocket.CONNECTING)) return;
  worldWs = new WebSocket(getWorldSocketUrl());
  worldWs.onopen = () => {
    worldWs.send(JSON.stringify({
      type: 'world_subscribe',
      area_id: player.area_id || DEFAULT_AREA_ID,
      instance_id: player.instance_id || null,
    }));
    worldWs.send(JSON.stringify({ type: 'duel_queue_subscribe' }));
    if(player.agent_id) {
      worldWs.send(JSON.stringify({ type: 'skill_subscribe', agent_id: player.agent_id }));
    }
    sendWorldUpdate(true);
  };
  worldWs.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      if(data.type === 'world_state' && Array.isArray(data.agents)) {
        if(data.area_id) player.area_id = data.area_id;
        player.instance_id = data.instance_id || null;
        worldAgents.clear();
        data.agents.forEach(agent => {
          if(agent.agent_id !== player.agent_id) {
            worldAgents.set(agent.agent_id, agent);
          }
        });
        if(Array.isArray(data.nodes)) {
          resourceNodes.clear();
          data.nodes.forEach(node => resourceNodes.set(node.node_id, node));
        }
      }
      if(data.type === 'world_update' && data.agent?.agent_id) {
        if(data.agent.agent_id !== player.agent_id && isSameShard(data.agent.area_id, data.agent.instance_id)) {
          worldAgents.set(data.agent.agent_id, data.agent);
        } else if(data.agent.agent_id !== player.agent_id) {
          worldAgents.delete(data.agent.agent_id);
        }
      }
      if(data.type === 'world_leave' && typeof data.agent_id === 'string') {
        worldAgents.delete(data.agent_id);
      }
      if(data.type === 'resource_node_update' && data.node?.node_id) {
        resourceNodes.set(data.node.node_id, data.node);
      }
      if(data.type === 'duel_queue_update' && Array.isArray(data.queue)) {
        duelQueue = data.queue;
        queuedForDuel = !!(player.agent_id && duelQueue.some(entry => entry.agent_id === player.agent_id));
      }
      if(data.type === 'duel_match_found' && player.agent_id && (data.p1 === player.agent_id || data.p2 === player.agent_id)) {
        queuedForDuel = false;
        startArenaFightFromMatch(data.fight_id);
      }
      if(data.type === 'tick_update' && arenaFight && data.fight_id === arenaFight.fight_id && data.state) {
        applyFightUpdate(data.state, data.result);
      }
      if(data.type === 'skill_xp' && data.gain) {
        const gain = data.gain;
        const skillState = player.skills[gain.skill] || { level: 1, xp: 0 };
        skillState.level = gain.new_level;
        skillState.xp = gain.total_xp;
        player.skills[gain.skill] = skillState;
        if(gain.gained_xp > 0) {
          markTutorialGoal('interact_node');
        }
        if(gain.gained_xp > 0) {
          showFloatingText(`+${gain.gained_xp} ${gain.skill} xp`, '#66d4ff');
        }
      }
      if(data.type === 'skill_level_up' && data.skill) {
        showFloatingText(`${data.skill} ${data.new_level}!`, '#d4a017');
      }
      if(data.type === 'inventory_update' && data.item_id) {
        player.inventory[data.item_id] = data.qty;
      }
      if(data.type === 'quest_update' && Array.isArray(data.quests)) {
        questLog = data.quests;
        const completed = (data.updates || []).find((update) => update.kind === 'completed');
        if(completed) {
          const quest = questLog.find((entry) => entry.quest_id === completed.quest_id);
          showFloatingText(`Quest complete: ${quest?.name || completed.quest_id}`, '#d4a017');
        }
      }
      if(data.type === 'world_interact_result' && data.ok === false && data.payload?.error) {
        showFloatingText(data.payload.error, '#cc3333');
      }
    } catch {}
  };
  worldWs.onclose = () => {
    if(player.registered) {
      setTimeout(connectWorldSocket, 1200);
    }
  };
}

function sendWorldUpdate(force = false) {
  if(!player.registered || !player.agent_id || player.inFight) return;
  if(!worldWs || worldWs.readyState !== WebSocket.OPEN) return;

  const now = Date.now();
  const zoneName = currentZone?.name || getZone(player.x).name;
  const areaId = player.area_id || DEFAULT_AREA_ID;
  const instanceId = player.instance_id || null;
  const movedFar = Math.hypot(player.x - worldBroadcastState.x, player.y - worldBroadcastState.y) > 16;
  const zoneChanged = zoneName !== worldBroadcastState.zone;
  const shardChanged = areaId !== worldBroadcastState.area_id || instanceId !== worldBroadcastState.instance_id;
  const intervalElapsed = now - worldBroadcastState.at > 140;
  if(!force && !movedFar && !zoneChanged && !shardChanged && !intervalElapsed) return;

  worldWs.send(JSON.stringify({
    type: 'world_update',
    agent_id: player.agent_id,
    combat_class: player.combat_class,
    avatar_id: player.avatar_id || DEFAULT_PLAYER_SPRITES[player.combat_class] || `player_${player.combat_class}`,
    x: Math.round(player.x),
    y: Math.round(player.y),
    zone: zoneName,
    area_id: areaId,
    instance_id: instanceId,
  }));

  worldBroadcastState.at = now;
  worldBroadcastState.x = player.x;
  worldBroadcastState.y = player.y;
  worldBroadcastState.zone = zoneName;
  worldBroadcastState.area_id = areaId;
  worldBroadcastState.instance_id = instanceId;
}

function leaveWorldPresence() {
  if(player.agent_id && worldWs && worldWs.readyState === WebSocket.OPEN) {
    try {
      worldWs.send(JSON.stringify({ type: 'world_leave', agent_id: player.agent_id }));
    } catch {}
  }
}

addEventListener('beforeunload', leaveWorldPresence);

// ─── PARTICLE SYSTEM ───
function spawnParticle(x, y, type, text='', color='#fff') {
  particles.push({ x, y, vx:(Math.random()-0.5)*3, vy:-2-Math.random()*3,
    life:1, type, text, color, size: type==='hitsplat'?16:4 });
}
function spawnHitsplat(x, y, damage, type='damage') {
  const col = type==='damage'?'#cc3333':type==='heal'?'#33cc33':type==='prayer'?'#3388cc':'#d4a017';
  particles.push({ x, y, vx:0, vy:-1.5, life:1.5, type:'hitsplat', text:String(damage), color:col, size:18 });
}

// ─── DRAW HELPERS ───
function drawRect(x, y, w, h, col) { ctx.fillStyle=col; ctx.fillRect(x-cam.x, y-cam.y, w, h); }
function drawText(text, x, y, col='#fff', size=12, align='center') {
  ctx.fillStyle=col; ctx.font=`${size}px 'Courier New',monospace`; ctx.textAlign=align;
  ctx.fillText(text, x-cam.x, y-cam.y);
}

// ─── DRAW CHARACTER (programmatic pixel-art style) ───
function drawCharacter(x, y, facing, walkFrame, colors, w=24, h=40, equipment=null, spriteKey=null) {
  const cx = x - cam.x;
  const cy = y - cam.y;
  const f = facing;
  const bob = Math.sin(walkFrame * 0.3) * 2;
  const legSwing = Math.sin(walkFrame * 0.6) * 6;

  if(spriteKey && generatedAssets.has(spriteKey)) {
    const sprite = generatedAssets.get(spriteKey);
    const drawW = w * 2.2;
    const drawH = h * 2.2;
    ctx.save();
    ctx.translate(cx, cy - h * 1.1 + bob);
    if(f < 0) {
      ctx.scale(-1, 1);
    }
    ctx.drawImage(sprite, -drawW / 2, -drawH + h * 0.9, drawW, drawH);
    ctx.restore();
    return;
  }

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(cx, cy, w*0.6, 4, 0, 0, Math.PI*2);
  ctx.fill();

  // Legs
  ctx.fillStyle = colors.legs || '#2a2a4a';
  ctx.fillRect(cx - 6, cy - 14 + legSwing*0.5, 5, 14);
  ctx.fillRect(cx + 1, cy - 14 - legSwing*0.5, 5, 14);

  // Body
  ctx.fillStyle = colors.body || '#3a3a5a';
  ctx.fillRect(cx - 8, cy - 30 + bob, 16, 18);

  // Cape
  if(equipment?.cape) {
    const capeColors = {fire:'#cc3300',infernal:'#ff4400',max:'#d4a017',accumulator:'#336633'};
    ctx.fillStyle = capeColors[equipment.cape] || '#333';
    ctx.fillRect(cx - 6*f - (f>0?8:0), cy - 28 + bob, 8, 16);
  }

  // Arms
  ctx.fillStyle = colors.arms || colors.body || '#3a3a5a';
  const armSwing = Math.sin(walkFrame * 0.6) * 8;
  ctx.fillRect(cx - 11, cy - 28 + bob + armSwing*0.3, 4, 12);
  ctx.fillRect(cx + 7, cy - 28 + bob - armSwing*0.3, 4, 12);

  // Head
  ctx.fillStyle = colors.skin || '#c8a882';
  ctx.fillRect(cx - 5, cy - 40 + bob, 10, 10);

  // Helmet/hat
  ctx.fillStyle = colors.hat || '#4a4a5a';
  ctx.fillRect(cx - 7, cy - 44 + bob, 14, 6);
  if(equipment?.armor === 'torva' || equipment?.armor === 'ancestral') {
    ctx.fillRect(cx - 8, cy - 46 + bob, 16, 4); // visor
  }

  // Eyes
  ctx.fillStyle = '#fff';
  ctx.fillRect(cx + (f>0?1:-4), cy - 38 + bob, 2, 2);
  ctx.fillStyle = '#000';
  ctx.fillRect(cx + (f>0?2:-3), cy - 38 + bob, 1, 2);

  // Weapon
  if(equipment?.weapon) {
    const wx = cx + 10*f;
    const wy = cy - 24 + bob;
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 2;
    if(['godsword','whip','scimitar'].some(w=>equipment.weapon.includes(w))) {
      // Melee weapon
      ctx.strokeStyle = '#ccccdd';
      ctx.beginPath();
      ctx.moveTo(wx, wy);
      ctx.lineTo(wx + 16*f, wy - 20);
      ctx.stroke();
      // Blade tip
      ctx.fillStyle = '#d4a017';
      ctx.fillRect(wx + 14*f, wy - 22, 4, 4);
    } else if(equipment.weapon.includes('bow') || equipment.weapon.includes('crossbow')) {
      ctx.strokeStyle = '#6a4a2a';
      ctx.beginPath();
      ctx.moveTo(wx, wy - 15);
      ctx.quadraticCurveTo(wx + 10*f, wy, wx, wy + 10);
      ctx.stroke();
    } else {
      // Staff
      ctx.strokeStyle = '#5a3a1a';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(wx, wy + 5);
      ctx.lineTo(wx + 4*f, wy - 25);
      ctx.stroke();
      ctx.fillStyle = '#3388cc';
      ctx.beginPath();
      ctx.arc(wx + 4*f, wy - 28, 5, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

// ─── DRAW NPC ───
function getNpcQuestMarker(npcId) {
  if(!Array.isArray(questLog) || questLog.length === 0) return null;

  for(const quest of questLog) {
    if(quest.turn_in_npc_id === npcId && quest.status === 'completed' && !quest.reward_claimed) {
      return '?';
    }
  }
  for(const quest of questLog) {
    if(quest.giver_npc_id === npcId && quest.status === 'not_started') {
      return '!';
    }
  }
  for(const quest of questLog) {
    if((quest.giver_npc_id === npcId || quest.turn_in_npc_id === npcId) && quest.status === 'in_progress') {
      return '*';
    }
  }
  return null;
}

function drawNPC(npc) {
  const bobVal = Math.sin(tick * 0.03 + npc.x) * 2;
  const facing = player.x > npc.x ? 1 : -1;
  const spriteKey = npc.sprite_key || (generatedAssetMeta.has(`npc_${npc.id}`) ? `npc_${npc.id}` : 'npc_villager');

  drawCharacter(npc.x, npc.y, facing, bobVal, {
    body: npc.color, hat: npc.hat, skin:'#c8a882', legs:'#2a2a3a'
  }, 24, 40, null, spriteKey);

  // Name tag
  const dist = Math.abs(player.x - npc.x);
  if(dist < 200) {
    const alpha = Math.max(0, 1 - dist/200);
    ctx.globalAlpha = alpha;
    const marker = getNpcQuestMarker(npc.id);
    if(marker) {
      ctx.fillStyle = marker === '?' ? '#66d4ff' : marker === '!' ? '#d4a017' : '#99cc66';
      ctx.font = 'bold 16px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(marker, npc.x - cam.x, npc.y - cam.y - 68);
    }
    drawText(npc.name, npc.x, npc.y - 52, '#d4a017', 11);
    if(dist < 80) {
      drawText('[E] Talk', npc.x, npc.y - 64, '#888', 9);
    }
    ctx.globalAlpha = 1;
  }
}

// ─── DRAW WORLD OBJECTS ───
function drawWorldObject(obj) {
  const ox = obj.x - cam.x;
  const oy = obj.y - cam.y;

  switch(obj.type) {
    case 'tree': {
      // Trunk
      ctx.fillStyle = '#3a2a1a';
      ctx.fillRect(ox + obj.w/2 - 6, oy, 12, obj.h);
      // Foliage
      ctx.fillStyle = obj.foliage || '#1a5a1a';
      ctx.beginPath();
      ctx.arc(ox + obj.w/2, oy - 10, obj.w/2 + 10, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = obj.foliage ? lighten(obj.foliage, 20) : '#2a6a2a';
      ctx.beginPath();
      ctx.arc(ox + obj.w/2 - 8, oy - 15, obj.w/3, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'dead_tree': {
      ctx.strokeStyle = '#3a2a1a';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(ox + obj.w/2, oy + obj.h);
      ctx.lineTo(ox + obj.w/2, oy);
      ctx.lineTo(ox, oy - 15);
      ctx.moveTo(ox + obj.w/2, oy + 15);
      ctx.lineTo(ox + obj.w, oy - 5);
      ctx.stroke();
      break;
    }
    case 'castle': {
      ctx.fillStyle = '#4a4a5a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      // Towers
      ctx.fillRect(ox - 15, oy - 40, 40, obj.h + 40);
      ctx.fillRect(ox + obj.w - 25, oy - 40, 40, obj.h + 40);
      // Battlements
      for(let i = 0; i < 4; i++) {
        ctx.fillRect(ox - 15 + i*12, oy - 52, 8, 12);
        ctx.fillRect(ox + obj.w - 25 + i*12, oy - 52, 8, 12);
      }
      // Gate
      ctx.fillStyle = '#2a1a0a';
      ctx.fillRect(ox + obj.w/2 - 20, oy + obj.h - 50, 40, 50);
      // Windows
      ctx.fillStyle = '#d4a017';
      ctx.fillRect(ox + 40, oy + 30, 12, 15);
      ctx.fillRect(ox + 100, oy + 30, 12, 15);
      ctx.fillRect(ox + 160, oy + 30, 12, 15);
      // Flag
      ctx.fillStyle = '#cc3333';
      ctx.fillRect(ox + obj.w/2 - 2, oy - 30, 4, -30);
      ctx.fillRect(ox + obj.w/2 + 2, oy - 58, 20, 12);
      break;
    }
    case 'house': {
      ctx.fillStyle = '#5a4a3a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = obj.roof || '#8a3a1a';
      ctx.beginPath();
      ctx.moveTo(ox - 10, oy);
      ctx.lineTo(ox + obj.w/2, oy - 30);
      ctx.lineTo(ox + obj.w + 10, oy);
      ctx.fill();
      ctx.fillStyle = '#2a1a0a';
      ctx.fillRect(ox + obj.w/2 - 12, oy + obj.h - 35, 24, 35);
      ctx.fillStyle = '#d4a017';
      ctx.fillRect(ox + 15, oy + 20, 10, 12);
      break;
    }
    case 'building': {
      ctx.fillStyle = '#5a5a6a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = obj.roof || '#5a2a2a';
      ctx.beginPath();
      ctx.moveTo(ox - 10, oy);
      ctx.lineTo(ox + obj.w/2, oy - 35);
      ctx.lineTo(ox + obj.w + 10, oy);
      ctx.fill();
      ctx.fillStyle = '#2a1a0a';
      ctx.fillRect(ox + obj.w/2 - 15, oy + obj.h - 40, 30, 40);
      if(obj.label) {
        ctx.fillStyle = '#d4a017';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(obj.label, ox + obj.w/2, oy - 40);
      }
      // Windows
      ctx.fillStyle = '#d4a017';
      ctx.fillRect(ox + 15, oy + 25, 12, 15);
      ctx.fillRect(ox + obj.w - 27, oy + 25, 12, 15);
      break;
    }
    case 'river': {
      const waveOffset = Math.sin(tick * 0.05) * 3;
      ctx.fillStyle = '#1a3a5a';
      ctx.fillRect(ox, oy + waveOffset, obj.w, obj.h);
      ctx.fillStyle = '#2a4a6a';
      for(let i = 0; i < obj.w; i += 20) {
        ctx.fillRect(ox + i + Math.sin(tick*0.08+i)*3, oy + waveOffset + 5, 10, 3);
      }
      break;
    }
    case 'bridge': {
      ctx.fillStyle = '#5a3a1a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = '#3a2a0a';
      ctx.fillRect(ox, oy, obj.w, 3);
      break;
    }
    case 'signpost': {
      ctx.fillStyle = '#5a3a1a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = obj.color || '#d4a017';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(obj.text, ox + obj.w/2, oy - 5);
      break;
    }
    case 'rock': {
      ctx.fillStyle = '#4a4a4a';
      ctx.beginPath();
      ctx.ellipse(ox + obj.w/2, oy + obj.h/2, obj.w/2, obj.h/2, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#5a5a5a';
      ctx.beginPath();
      ctx.ellipse(ox + obj.w/2 - 3, oy + obj.h/3, obj.w/3, obj.h/3, 0, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'fountain': {
      ctx.fillStyle = '#5a5a6a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = '#2a4a6a';
      ctx.fillRect(ox + 5, oy + 5, obj.w - 10, obj.h - 15);
      // Water spray
      const spray = Math.sin(tick * 0.1) * 5;
      ctx.fillStyle = '#4a7aaa';
      ctx.beginPath();
      ctx.arc(ox + obj.w/2, oy - 5 + spray, 4, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'statue': {
      ctx.fillStyle = '#6a6a7a';
      ctx.fillRect(ox + 5, oy + obj.h - 50, 20, 50);
      ctx.fillRect(ox, oy + obj.h - 10, 30, 10);
      ctx.beginPath();
      ctx.arc(ox + 15, oy + obj.h - 55, 8, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'wall_section': {
      ctx.fillStyle = obj.color || '#4a4a5a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      for(let i = 0; i < 5; i++) {
        ctx.fillRect(ox + (i%2)*20 - 5, oy - 8 + i*0, 12, 8);
      }
      break;
    }
    case 'ditch': {
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      break;
    }
    case 'bones': {
      ctx.fillStyle = '#c8c8aa';
      ctx.fillRect(ox, oy, obj.w*0.7, 3);
      ctx.fillRect(ox + 5, oy - 3, 3, 8);
      ctx.fillRect(ox + 15, oy - 2, 3, 7);
      break;
    }
    case 'skull_pile': {
      ctx.fillStyle = '#aaa88a';
      for(let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.arc(ox + 10 + i*10, oy + obj.h - 8, 7, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#222';
        ctx.fillRect(ox + 8 + i*10, oy + obj.h - 10, 2, 2);
        ctx.fillRect(ox + 12 + i*10, oy + obj.h - 10, 2, 2);
        ctx.fillStyle = '#aaa88a';
      }
      break;
    }
    case 'lava_pool': {
      const lavaGlow = 0.5 + Math.sin(tick * 0.08) * 0.3;
      ctx.fillStyle = `rgba(204,51,0,${lavaGlow})`;
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = `rgba(255,120,0,${lavaGlow*0.5})`;
      for(let i = 0; i < obj.w; i += 15) {
        ctx.beginPath();
        ctx.arc(ox + i + Math.sin(tick*0.06+i)*4, oy + obj.h/2, 5, 0, Math.PI*2);
        ctx.fill();
      }
      break;
    }
    case 'arena_gate': {
      ctx.fillStyle = '#3a3a5a';
      ctx.fillRect(ox, oy, 20, obj.h);
      ctx.fillRect(ox + obj.w - 20, oy, 20, obj.h);
      ctx.fillRect(ox, oy, obj.w, 25);
      // Arch
      ctx.fillStyle = '#d4a017';
      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('⚔ EMIR\'S ARENA ⚔', ox + obj.w/2, oy + 16);
      // Torches on pillars
      const flicker = Math.sin(tick * 0.15) * 3;
      ctx.fillStyle = '#ff8800';
      ctx.beginPath();
      ctx.arc(ox + 10, oy - 5 + flicker, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(ox + obj.w - 10, oy - 5 - flicker, 6, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'arena_pillar': {
      ctx.fillStyle = obj.color || '#3a3a5a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      ctx.fillStyle = '#d4a017';
      ctx.fillRect(ox - 3, oy, obj.w + 6, 5);
      ctx.fillRect(ox - 3, oy + obj.h - 5, obj.w + 6, 5);
      break;
    }
    case 'arena_floor': {
      ctx.fillStyle = obj.color || '#1a1a3a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      // Grid lines
      ctx.strokeStyle = '#2a2a4a';
      ctx.lineWidth = 1;
      for(let i = 0; i < obj.w; i += 60) {
        ctx.beginPath();
        ctx.moveTo(ox + i, oy);
        ctx.lineTo(ox + i, oy + obj.h);
        ctx.stroke();
      }
      break;
    }
    case 'torch': {
      ctx.fillStyle = '#3a2a1a';
      ctx.fillRect(ox, oy, obj.w, obj.h);
      const f1 = Math.sin(tick*0.12 + obj.x)*4;
      const f2 = Math.cos(tick*0.15 + obj.x)*3;
      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.arc(ox + obj.w/2, oy - 5 + f1, 8, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#ffaa00';
      ctx.beginPath();
      ctx.arc(ox + obj.w/2 + f2, oy - 8, 4, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'duel_portal': {
      const pulse = 0.6 + Math.sin(tick * 0.08) * 0.3;
      ctx.fillStyle = '#3a244f';
      ctx.fillRect(ox + 20, oy + 24, 40, obj.h - 24);
      ctx.fillStyle = `rgba(125,85,255,${pulse})`;
      ctx.beginPath();
      ctx.ellipse(ox + obj.w/2, oy + obj.h/2 - 10, 26, 58, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#d4a017';
      ctx.lineWidth = 2;
      ctx.strokeRect(ox + 18, oy + 20, 44, obj.h - 20);
      ctx.fillStyle = '#d4a017';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('EMIR\'S', ox + obj.w / 2, oy + 14);
      ctx.fillText('PORTAL', ox + obj.w / 2, oy + obj.h + 14);
      break;
    }
    case 'area_portal': {
      const pulse = 0.55 + Math.sin(tick * 0.08 + obj.x * 0.01) * 0.25;
      const tint = obj.tint || '#4f67ff';
      ctx.fillStyle = '#2a2a44';
      ctx.fillRect(ox + 10, oy + 20, obj.w - 20, obj.h - 20);
      ctx.fillStyle = tint;
      ctx.globalAlpha = pulse;
      ctx.beginPath();
      ctx.ellipse(ox + obj.w/2, oy + obj.h/2 - 6, 18, 48, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#d4a017';
      ctx.lineWidth = 2;
      ctx.strokeRect(ox + 8, oy + 16, obj.w - 16, obj.h - 16);
      ctx.fillStyle = '#d4a017';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText((obj.label || 'Portal').toUpperCase().slice(0, 12), ox + obj.w / 2, oy + obj.h + 14);
      break;
    }
    case 'crystal': {
      ctx.fillStyle = obj.color || '#7f8dff';
      ctx.beginPath();
      ctx.moveTo(ox + obj.w/2, oy);
      ctx.lineTo(ox + obj.w, oy + obj.h*0.35);
      ctx.lineTo(ox + obj.w*0.74, oy + obj.h);
      ctx.lineTo(ox + obj.w*0.26, oy + obj.h);
      ctx.lineTo(ox, oy + obj.h*0.35);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#d4e1ff';
      ctx.lineWidth = 1;
      ctx.stroke();
      break;
    }
  }
}

function lighten(hex, amt) {
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  r = Math.min(255, r+amt); g = Math.min(255, g+amt); b = Math.min(255, b+amt);
  return `rgb(${r},${g},${b})`;
}

function getSkillVisual(skill) {
  const visuals = {
    mining: { color:'#aab0b9', icon:'⛏' },
    woodcutting: { color:'#5a8f4f', icon:'🌲' },
    fishing: { color:'#4fa7db', icon:'🐟' },
    runecrafting: { color:'#7f8dff', icon:'✦' },
    smithing: { color:'#c1a86a', icon:'⚒' },
    cooking: { color:'#ff9955', icon:'🍲' },
    firemaking: { color:'#ff5533', icon:'🔥' },
    crafting: { color:'#b27ed6', icon:'◆' },
    fletching: { color:'#79a06d', icon:'➶' },
    herblore: { color:'#52b574', icon:'✿' },
    agility: { color:'#62d4bf', icon:'↯' },
    thieving: { color:'#c9c257', icon:'☗' },
    hunter: { color:'#a07654', icon:'◌' },
    slayer: { color:'#a55a5a', icon:'☠' },
    farming: { color:'#72b45f', icon:'☘' },
    construction: { color:'#b4845f', icon:'▦' },
    prayer: { color:'#88a6ff', icon:'☼' },
    sailing: { color:'#54b0bf', icon:'⚓' },
  };
  return visuals[skill] || { color:'#66aa44', icon:'●' };
}

function formatSkillName(skill) {
  return SKILL_LABELS[skill] || skill.replace(/_/g, ' ');
}

// ─── GET CURRENT ZONE ───
function getZone(x) {
  const zones = getAreaZones();
  for(const z of zones) { if(x >= z.x && x < z.x + z.w) return z; }
  return zones[zones.length - 1];
}

// ─── DIALOGUE SYSTEM ───
const dialogueBox = document.getElementById('dialogue-box');
const dialogueSpeakerEl = dialogueBox.querySelector('.speaker');
const dialogueTextEl = dialogueBox.querySelector('.text');
const dialogueChoicesEl = dialogueBox.querySelector('.choices');
const dialoguePromptEl = dialogueBox.querySelector('.prompt');

async function startDialogueTree(npcId) {
  if(!player.agent_id) return null;
  try {
    const res = await apiFetch('/api/v1/world/dialogue/start', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        agent_id: player.agent_id,
        npc_id: npcId,
      }),
    });
    const data = await res.json();
    if(!res.ok || !data.node) return null;
    if(Array.isArray(data.quests)) {
      questLog = data.quests;
    }
    return data.node;
  } catch {
    return null;
  }
}

function renderDialogueTreeNode() {
  if(!dialogueState || dialogueState.mode !== 'tree') return;
  const node = dialogueState.node;
  if(!node) { closeDialogue(); return; }

  dialogueBox.style.display = 'block';
  dialogueSpeakerEl.textContent = node.speaker || dialogueState.npc?.name || 'NPC';
  dialogueTextEl.textContent = node.text;
  dialogueChoicesEl.innerHTML = node.choices.map((choice, idx) => (
    `<button class="choice-btn" onclick="chooseDialogueChoice('${choice.choice_id}')">[${idx + 1}] ${choice.text}</button>`
  )).join('');
  dialoguePromptEl.textContent = '[1-4] Choose | [E] Select single option | [Q] Close';
}

async function openDialogue(npc) {
  const treeNode = await startDialogueTree(npc.id);
  if(treeNode) {
    dialogueState = { mode:'tree', npc, npcId:npc.id, node:treeNode };
    renderDialogueTreeNode();
    return;
  }

  dialogueState = { mode:'linear', npc, lineIndex: 0 };
  showDialogueLine();
}

function showDialogueLine() {
  if(!dialogueState || dialogueState.mode !== 'linear') return;
  const {npc, lineIndex} = dialogueState;
  if(lineIndex >= npc.dialogue.length) { closeDialogue(); return; }
  dialogueBox.style.display = 'block';
  dialogueSpeakerEl.textContent = npc.name;
  dialogueTextEl.textContent = npc.dialogue[lineIndex];
  dialogueChoicesEl.innerHTML = '';
  if(npc.isArenaMaster && lineIndex === npc.dialogue.length - 1) {
    dialoguePromptEl.textContent = '[E] Continue | [F] Register for Arena | [Q] Close';
  } else {
    dialoguePromptEl.textContent = '[E] Continue | [Q] Close';
  }
}

window.chooseDialogueChoice = async function(choiceId) {
  if(!dialogueState || dialogueState.mode !== 'tree' || !player.agent_id) return;
  try {
    const res = await apiFetch('/api/v1/world/dialogue/choose', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        agent_id: player.agent_id,
        npc_id: dialogueState.npcId,
        node_id: dialogueState.node?.node_id,
        choice_id: choiceId,
      }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Dialogue failed', '#cc3333');
      return;
    }

    if(Array.isArray(data.quests)) {
      questLog = data.quests;
    }
    if(data.skills) {
      player.skills = data.skills;
    }
    if(data.inventory) {
      player.inventory = data.inventory;
    }
    if(data.reward?.quest_id) {
      const quest = questLog.find((entry) => entry.quest_id === data.reward.quest_id);
      showFloatingText(`Reward claimed: ${quest?.name || data.reward.quest_id}`, '#66d4ff');
    }

    if(data.closed || !data.node) {
      closeDialogue();
      return;
    }

    dialogueState.node = data.node;
    renderDialogueTreeNode();
  } catch {
    showFloatingText('Dialogue failed', '#cc3333');
  }
};

function advanceDialogue() {
  if(!dialogueState) return;
  if(dialogueState.mode === 'tree') {
    const nodeChoices = dialogueState.node?.choices || [];
    if(nodeChoices.length === 1) {
      window.chooseDialogueChoice(nodeChoices[0].choice_id);
    }
    return;
  }
  dialogueState.lineIndex++;
  showDialogueLine();
}
function closeDialogue() {
  dialogueState = null;
  dialogueChoicesEl.innerHTML = '';
  dialogueBox.style.display = 'none';
}

// ─── ZONE LABEL ───
const zoneLabelEl = document.getElementById('zone-label');
let lastZoneName = '';
function showZoneLabel(name) {
  if(name === lastZoneName) return;
  lastZoneName = name;
  zoneLabelEl.textContent = '~ ' + name + ' ~';
  zoneLabelEl.classList.add('show');
  setTimeout(() => zoneLabelEl.classList.remove('show'), 2500);
}

// ─── ARENA REGISTRATION ───
const combatOverlay = document.getElementById('combat-overlay');

async function registerForArena() {
  if(player.registered) {
    showFloatingText('Already registered!', '#d4a017');
    return;
  }
  const stored = loadStoredAuth();
  const walletAddress = normalizeWalletAddress(
    player.wallet_address || stored?.wallet_address || createLocalWalletAddress()
  );
  const meleeOptions = getSpriteOptionsForClass('melee');
  const rangedOptions = getSpriteOptionsForClass('ranged');
  const magicOptions = getSpriteOptionsForClass('magic');
  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = `
    <div style="text-align:center">
      <div style="color:#d4a017;font-size:16px;margin-bottom:12px">⚔ ARENA REGISTRATION ⚔</div>
      <div style="color:#8d95a6;font-size:11px;margin-bottom:8px">Wallet Identity (humans + autonomous agents use the same rules)</div>
      <input id="wallet-address-input" value="${walletAddress}" style="width:420px;max-width:90%;padding:7px;background:#121723;border:1px solid #33495d;color:#9fb8d6;font-family:monospace;font-size:11px;margin-bottom:10px" />
      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;margin-bottom:10px">
        <div style="border:1px solid #33495d;padding:6px;background:rgba(14,20,30,.72)">
          <div style="font-size:11px;color:#cc6666;margin-bottom:4px">Melee Avatar</div>
          <select id="avatar-select-melee" style="width:100%;padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:10px">
            ${meleeOptions.map((id) => `<option value="${id}" ${id === (player.avatar_id || DEFAULT_PLAYER_SPRITES.melee) ? 'selected' : ''}>${id}</option>`).join('')}
          </select>
        </div>
        <div style="border:1px solid #33495d;padding:6px;background:rgba(14,20,30,.72)">
          <div style="font-size:11px;color:#66cc66;margin-bottom:4px">Ranged Avatar</div>
          <select id="avatar-select-ranged" style="width:100%;padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:10px">
            ${rangedOptions.map((id) => `<option value="${id}" ${id === DEFAULT_PLAYER_SPRITES.ranged ? 'selected' : ''}>${id}</option>`).join('')}
          </select>
        </div>
        <div style="border:1px solid #33495d;padding:6px;background:rgba(14,20,30,.72)">
          <div style="font-size:11px;color:#6699ff;margin-bottom:4px">Magic Avatar</div>
          <select id="avatar-select-magic" style="width:100%;padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:10px">
            ${magicOptions.map((id) => `<option value="${id}" ${id === DEFAULT_PLAYER_SPRITES.magic ? 'selected' : ''}>${id}</option>`).join('')}
          </select>
        </div>
      </div>
      <div style="margin-bottom:8px;color:#aaa">Choose your combat class:</div>
      <div style="display:flex;gap:10px;justify-content:center;margin-bottom:12px">
        <button onclick="selectClass('melee')" style="padding:8px 16px;background:#cc3333;border:2px solid #ff4444;color:#fff;cursor:pointer;font-family:monospace;font-size:13px">⚔ Melee</button>
        <button onclick="selectClass('ranged')" style="padding:8px 16px;background:#33cc33;border:2px solid #44ff44;color:#fff;cursor:pointer;font-family:monospace;font-size:13px">🏹 Ranged</button>
        <button onclick="selectClass('magic')" style="padding:8px 16px;background:#3388cc;border:2px solid #44aaff;color:#fff;cursor:pointer;font-family:monospace;font-size:13px">✦ Magic</button>
      </div>
      <div style="color:#666;font-size:11px">Press Q to cancel</div>
    </div>`;
}

async function authenticateWalletSession(walletInput, combatClass) {
  const walletAddress = normalizeWalletAddress(walletInput || player.wallet_address || createLocalWalletAddress());
  const challengeRes = await apiFetch('/api/v1/auth/wallet/challenge', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ wallet_address: walletAddress }),
  });
  const challengeData = await challengeRes.json();
  if(!challengeRes.ok || !challengeData?.nonce) {
    throw new Error(challengeData?.error || 'Wallet challenge failed');
  }

  const verifyRes = await apiFetch('/api/v1/auth/wallet/verify', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      wallet_address: walletAddress,
      nonce: challengeData.nonce,
      signature: `signed:${walletAddress}:${challengeData.nonce}`,
      character_name: `Agent_${walletAddress.slice(2, 8)}`,
      combat_class: combatClass,
    }),
  });
  const verifyData = await verifyRes.json();
  if(!verifyRes.ok || !verifyData?.session_token || !verifyData?.character?.character_id) {
    throw new Error(verifyData?.error || 'Wallet verify failed');
  }

  player.session_token = verifyData.session_token;
  player.wallet_address = verifyData.account?.wallet_address || walletAddress;
  player.account_id = verifyData.account?.account_id || null;
  player.agent_id = verifyData.character.character_id;
  player.character_name = verifyData.character?.name || player.character_name;
  player.mode = verifyData.character?.mode || player.mode;
  player.actor_type = verifyData.account?.account_type || player.actor_type;
  saveStoredAuth();

  return verifyData;
}

window.selectClass = async function(cls) {
  try {
    const walletInput = document.getElementById('wallet-address-input')?.value || '';
    const selectedAvatar = document.getElementById(`avatar-select-${cls}`)?.value || DEFAULT_PLAYER_SPRITES[cls] || `player_${cls}`;
    const auth = await authenticateWalletSession(walletInput, cls);
    const id = auth.character.character_id;
    const res = await apiFetch('/api/v1/arena/register/self', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        combat_class: cls,
        avatar_id: selectedAvatar,
        prayer_book: 'normal',
      }),
    });
    const data = await res.json();
    if(data.status === 'registered') {
      player.agent_id = data.character?.character_id || id;
      player.character_name = data.character?.name || player.character_name;
      player.mode = data.character?.mode || player.mode;
      player.actor_type = data.account_type || player.actor_type;
      player.combat_class = cls;
      player.avatar_id = selectedAvatar;
      player.registered = true;
      player.area_id = DEFAULT_AREA_ID;
      player.instance_id = null;
      combatOverlay.style.display = 'none';
      registrationOpen = false;
      showFloatingText(`Registered as ${cls}! ID: ${id}`, '#33cc33');

      // Update equipment based on class
      player.equipment = getEquipmentForClass(cls);
      hydrateTutorialState(player.agent_id);
      updateTutorialTracker();
      saveStoredAuth();

      connectWorldSocket();
      sendWorldUpdate(true);
      await loadCharacterState();
      await fetchResourceNodes();
      await loadQuestJournal();
    } else {
      showFloatingText(data.error || 'Registration failed!', '#cc3333');
    }
  } catch(e) { showFloatingText('Registration failed!', '#cc3333'); }
};

function setWorldStateFromServer(world) {
  if(!world) return;
  if(typeof world.x === 'number') player.x = world.x;
  if(typeof world.y === 'number') player.y = world.y;
  if(typeof world.avatar_id === 'string' && world.avatar_id.length > 0) {
    player.avatar_id = world.avatar_id;
  }
  player.area_id = world.area_id || DEFAULT_AREA_ID;
  player.instance_id = world.instance_id || null;
  worldAgents.clear();
  resourceNodes.clear();
  currentZone = getZone(player.x);
  if(worldWs && worldWs.readyState === WebSocket.OPEN) {
    worldWs.send(JSON.stringify({
      type:'world_subscribe',
      area_id: player.area_id,
      instance_id: player.instance_id,
    }));
  }
}

async function loadProfile() {
  if(!player.agent_id) return;
  try {
    const res = await apiFetch('/api/v1/profile/' + player.agent_id);
    if(!res.ok) return;
    const data = await res.json();
    player.skills = data.progress?.skills || player.skills;
    player.inventory = data.progress?.inventory || player.inventory;
    player.character_name = data.character?.name || player.character_name;
    player.mode = data.character?.mode || player.mode;
    questLog = data.quests || questLog;
    queuedForDuel = !!data.queue;
    if(data.world) {
      setWorldStateFromServer(data.world);
      if(typeof data.world.avatar_id === 'string' && data.world.avatar_id.length > 0) {
        player.avatar_id = data.world.avatar_id;
      }
    }
    if(player.agent_id && tutorialState.character_id !== player.agent_id) {
      hydrateTutorialState(player.agent_id);
    }
    await refreshChallengeState();
  } catch {}
}

async function loadCharacterState() {
  if(!player.session_token) {
    await loadProfile();
    return;
  }

  try {
    const res = await apiFetch('/api/v1/character/state');
    if(!res.ok) {
      if(res.status === 401) clearStoredAuth();
      await loadProfile();
      return;
    }
    const data = await res.json();
    player.skills = data.progress?.skills || player.skills;
    player.inventory = data.progress?.inventory || player.inventory;
    player.bank = data.bank || player.bank || {};
    player.agent_id = data.character_id || player.agent_id;
    player.mode = data.mode || player.mode;
    if(player.agent_id) player.registered = true;
    queuedForDuel = !!data.queue;
    if(data.world) {
      setWorldStateFromServer(data.world);
    }
    if(Array.isArray(data.quests)) {
      questLog = data.quests;
    }
    if(player.agent_id && tutorialState.character_id !== player.agent_id) {
      hydrateTutorialState(player.agent_id);
    }
    await refreshChallengeState();
  } catch {
    await loadProfile();
  }
}

async function loadQuestJournal() {
  if(!player.agent_id) return;
  try {
    if(player.session_token) {
      const canonical = await apiFetch('/api/v1/quests');
      if(canonical.ok) {
        const data = await canonical.json();
        if(Array.isArray(data.quests)) {
          questLog = data.quests;
          return;
        }
      }
    }

    const legacy = await apiFetch('/api/v1/world/quests/' + player.agent_id);
    if(!legacy.ok) return;
    const data = await legacy.json();
    if(Array.isArray(data.quests)) {
      questLog = data.quests;
    }
  } catch {}
}

async function fetchResourceNodes() {
  try {
    const areaId = encodeURIComponent(player.area_id || DEFAULT_AREA_ID);
    const instanceParam = player.instance_id ? `&instance_id=${encodeURIComponent(player.instance_id)}` : '';
    const res = await apiFetch(`/api/v1/world/nodes?area_id=${areaId}${instanceParam}`);
    if(!res.ok) return;
    const nodes = await res.json();
    if(Array.isArray(nodes)) {
      resourceNodes.clear();
      nodes.forEach(node => resourceNodes.set(node.node_id, node));
    }
  } catch {}
}

function openDuelQueueOverlay() {
  if(!player.registered || !player.agent_id) {
    registerForArena();
    return;
  }

  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = `
    <div style="text-align:center">
      <div style="color:#d4a017;font-size:16px;margin-bottom:10px">⚔ EMIR'S ARENA QUEUE ⚔</div>
      <div style="margin-bottom:8px;color:#aaa">${queuedForDuel ? 'You are currently queued for a duel.' : 'Join the queue to find a duel.'}</div>
      <div style="display:flex;gap:10px;justify-content:center;margin-bottom:10px">
        <button onclick="joinDuelQueue()" style="padding:8px 16px;background:#2c7;border:2px solid #4fa;color:#fff;cursor:pointer;font-family:monospace;font-size:13px">Join Queue</button>
        <button onclick="leaveDuelQueue()" style="padding:8px 16px;background:#933;border:2px solid #c55;color:#fff;cursor:pointer;font-family:monospace;font-size:13px">Leave Queue</button>
      </div>
      <div style="color:#888;font-size:11px">Queue size: ${duelQueue.length}</div>
      <div style="color:#666;font-size:11px;margin-top:6px">Press Q to close</div>
    </div>`;
}

window.joinDuelQueue = async function() {
  if(!player.agent_id) return;
  try {
    const res = await apiFetch('/api/v1/world/portal/use', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        agent_id: player.agent_id,
        portal_id: 'emirs_arena_portal',
        arena: 'duel_arena',
      })
    });
    const data = await res.json();
    if(res.ok) {
      queuedForDuel = true;
      showFloatingText(`Queued (${data.queue_size})`, '#d4a017');
      openDuelQueueOverlay();
    } else {
      showFloatingText(data.error || 'Queue failed', '#cc3333');
    }
  } catch(e) {
    showFloatingText('Queue failed', '#cc3333');
  }
};

window.leaveDuelQueue = async function() {
  if(!player.agent_id) return;
  try {
    const res = await apiFetch('/api/v1/arena/queue/leave', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ agent_id: player.agent_id })
    });
    await res.json();
    queuedForDuel = false;
    showFloatingText('Left queue', '#999');
    openDuelQueueOverlay();
  } catch {}
};

function openSkillsOverlay() {
  if(!player.agent_id) {
    registerForArena();
    return;
  }

  const nearbyCounts = {};
  resourceNodes.forEach((node) => {
    if(!isSameShard(node.area_id, node.instance_id)) return;
    nearbyCounts[node.skill] = (nearbyCounts[node.skill] || 0) + 1;
  });

  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = `
    <div style="text-align:left;max-height:380px;overflow:auto;min-width:560px">
      <div style="text-align:center;color:#66d4ff;font-size:16px;margin-bottom:10px">📘 SKILL JOURNAL</div>
      <div style="color:#aaa;margin-bottom:8px">Agent: ${player.agent_id} | Area: ${player.area_id || DEFAULT_AREA_ID}</div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px">
        ${SKILL_DISPLAY_ORDER.map((skill) => {
          const state = player.skills?.[skill] || { level: 1, xp: 0 };
          const visual = getSkillVisual(skill);
          const nearby = nearbyCounts[skill] || 0;
          return `<div style="border:1px solid #334;padding:7px;background:rgba(12,14,20,.82)">
            <div style="display:flex;justify-content:space-between;gap:8px;align-items:center">
              <div style="color:${visual.color};font-size:12px">${visual.icon} ${formatSkillName(skill)}</div>
              <div style="color:#d4a017;font-size:12px">Lv ${state.level}</div>
            </div>
            <div style="color:#8d95a6;font-size:10px;margin-top:3px">XP ${state.xp}</div>
            <div style="color:#6f89a9;font-size:10px;margin-top:2px">Activities in area: ${nearby}</div>
          </div>`;
        }).join('')}
      </div>
      <div style="margin-top:10px;border:1px solid #2c2f3b;background:rgba(10,12,18,.8);padding:8px">
        <div style="color:#9ea8bb;font-size:11px;margin-bottom:4px">Members Skills (Locked in 2007 F2P mode)</div>
        <div style="display:flex;flex-wrap:wrap;gap:6px">
          ${MEMBERS_SKILL_DISPLAY_ORDER.map((skill) => `<span style="font-size:10px;color:#6e7687;border:1px solid #333;padding:2px 5px;border-radius:3px">${formatSkillName(skill)}</span>`).join('')}
        </div>
      </div>
      <div style="color:#8a8a9a;font-size:11px;margin-top:8px">
        Train with [E] near nodes, craft runes in Nexus, then cast teleports from [B] spellbook.
      </div>
      <div style="text-align:center;color:#666;font-size:11px;margin-top:8px">Press Q or K to close</div>
    </div>`;
}

async function openAtlasOverlay() {
  try {
    const res = await apiFetch('/api/v1/world/atlas');
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Atlas unavailable', '#cc3333');
      return;
    }
    const currentAreaId = player.area_id || DEFAULT_AREA_ID;
    const currentArea = (data.areas || []).find((area) => area.area_id === currentAreaId);
    const exits = (data.portals || []).filter((portal) => portal.from_area_id === currentAreaId);
    const areaSummary = (data.area_summaries || []).find((summary) => summary.area_id === currentAreaId);

    registrationOpen = true;
    combatOverlay.style.display = 'block';
    combatOverlay.innerHTML = `
      <div style="text-align:left;max-height:380px;overflow:auto;min-width:620px">
        <div style="text-align:center;color:#8fd2ff;font-size:16px;margin-bottom:8px">🗺 WORLD ATLAS</div>
        <div style="color:#aaa;margin-bottom:6px">
          Area: ${(currentArea?.name || currentAreaId)} · Environment: ${(currentArea?.environment || 'unknown')} · Scope: ${(currentArea?.shared ? 'shared multiplayer' : 'personal instance')}
        </div>
        <div style="color:#8a8a9a;font-size:11px;margin-bottom:6px">
          Scene: ${(areaSummary?.scene_type || currentArea?.scene_type || 'side_scroller')} · Travel Budget: ${(areaSummary?.core_budget_ok ? 'within 2 hops' : 'exceeds budget')}
        </div>
        <div style="color:#8a8a9a;font-size:11px;margin-bottom:10px">
          Total Areas: ${(data.areas || []).length} · Portals: ${data.total_portals || 0} · Training Nodes: ${data.total_nodes || 0}
        </div>
        <div style="border:1px solid #334;padding:8px;background:rgba(14,16,24,.82);margin-bottom:8px">
          <div style="color:#d4a017;font-size:12px;margin-bottom:6px">Exits From Current Area</div>
          <div style="display:grid;grid-template-columns:1fr;gap:4px">
            ${exits.map((portal) => `<div style="display:flex;justify-content:space-between;font-size:11px;color:#b6c2d8">
              <span>${portal.name}</span>
              <span style="color:#7fa1ff">${portal.to_area_id} (${portal.kind})</span>
            </div>`).join('') || '<div style="font-size:11px;color:#777">No exits in this shard</div>'}
          </div>
        </div>
        <div style="border:1px solid #334;padding:8px;background:rgba(14,16,24,.82);margin-bottom:8px">
          <div style="color:#66d4ff;font-size:12px;margin-bottom:6px">Skills Available In Current Area</div>
          <div style="display:flex;flex-wrap:wrap;gap:6px">
            ${Object.entries(areaSummary?.skill_counts || {}).sort((a,b)=>a[0].localeCompare(b[0])).map(([skill, count]) => {
              const visual = getSkillVisual(skill);
              return `<span style="font-size:11px;padding:3px 6px;border:1px solid #3a4f66;background:rgba(10,20,30,.7);color:${visual.color}">
                ${visual.icon} ${formatSkillName(skill)} ×${count}
              </span>`;
            }).join('') || '<span style="font-size:11px;color:#777">No skill nodes mapped</span>'}
          </div>
        </div>
        <div style="color:#7e91a7;font-size:11px">Tip: [M] atlas + [B] spellbook + portals gives short travel even as the world expands.</div>
        <div style="text-align:center;color:#666;font-size:11px;margin-top:8px">Press Q or M to close</div>
      </div>`;
  } catch {
    showFloatingText('Atlas unavailable', '#cc3333');
  }
}

async function openSpellbookOverlay() {
  if(!player.agent_id) {
    registerForArena();
    return;
  }

  try {
    const res = await apiFetch('/api/v1/world/spellbook/' + player.agent_id);
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Spellbook unavailable', '#cc3333');
      return;
    }
    player.spellbook = data.spells || [];
    registrationOpen = true;
    combatOverlay.style.display = 'block';
    combatOverlay.innerHTML = `
      <div style=\"text-align:left;max-height:360px;overflow:auto;min-width:520px\">
        <div style=\"text-align:center;color:#7fa1ff;font-size:16px;margin-bottom:10px\">✦ SPELLBOOK ✦</div>
        <div style=\"color:#aaa;margin-bottom:8px\">Magic: ${data.magic_level} | Runecrafting: ${data.runecrafting_level}</div>
        <div style=\"display:grid;grid-template-columns:1fr;gap:6px\">
          ${(data.spells || []).map((spell) => {
            const runes = spell.runes.map((r) => renderItemInline(r.item_id, `${r.qty_owned}/${r.qty_required}`, '#9ab0ff')).join(' ');
            const buttonLabel = spell.teleport ? 'Cast Teleport' : 'Cast';
            const disabled = spell.can_cast ? '' : 'disabled';
            const bg = spell.can_cast ? '#294d9f' : '#333';
            const destination = spell.teleport ? `${spell.teleport.area_id} · ${spell.teleport.zone}` : 'Combat spell';
            return `<div style=\"border:1px solid #445;padding:8px;background:rgba(20,20,40,.75)\">
              <div style=\"display:flex;justify-content:space-between;align-items:center;gap:10px\">
                <div>
                  <div style=\"color:#d4e1ff;font-size:13px\">${spell.spell}</div>
                  <div style=\"color:#9ab0ff;font-size:11px\">Requires magic ${spell.magic_level_required}</div>
                  <div style=\"color:#8a8a9a;font-size:11px;display:flex;flex-wrap:wrap;gap:6px;margin-top:3px\">${runes}</div>
                  <div style=\"color:#6787b3;font-size:10px\">${destination}</div>
                </div>
                <button onclick=\"castSpell('${spell.spell}')\" ${disabled} style=\"padding:6px 10px;background:${bg};border:1px solid #678;color:#fff;cursor:pointer;font-family:monospace;font-size:11px\">${buttonLabel}</button>
              </div>
            </div>`;
          }).join('')}
        </div>
        <div style=\"text-align:center;color:#666;font-size:11px;margin-top:8px\">Press Q or B to close</div>
      </div>`;
    markTutorialGoal('open_spellbook');
  } catch {
    showFloatingText('Spellbook unavailable', '#cc3333');
  }
}

window.castSpell = async function(spellName) {
  if(!player.agent_id) return;
  try {
    const res = await apiFetch('/api/v1/world/spell/cast', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ agent_id: player.agent_id, spell: spellName }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Spell failed', '#cc3333');
      return;
    }

    if(data.inventory) player.inventory = data.inventory;
    if(data.gain?.skill) {
      const existing = player.skills[data.gain.skill] || { level: 1, xp: 0 };
      existing.level = data.gain.new_level;
      existing.xp = data.gain.total_xp;
      player.skills[data.gain.skill] = existing;
      showFloatingText(`${spellName} cast`, '#7fa1ff');
    }
    if(data.world) {
      setWorldStateFromServer(data.world);
      await fetchResourceNodes();
      sendWorldUpdate(true);
      showZoneLabel(getZone(player.x)?.name || 'Unknown');
      if(data.scope === 'personal') {
        showFloatingText('Entered personal instance', '#8fd2ff');
      }
    }
    await loadQuestJournal();
    await openSpellbookOverlay();
  } catch {
    showFloatingText('Spell failed', '#cc3333');
  }
};

function escJs(value) {
  return String(value).replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

function getGeneratedAssetPath(assetId) {
  return generatedAssetMeta.get(assetId)?.path || null;
}

function closeCombatOverlay() {
  combatOverlay.style.display = 'none';
  registrationOpen = false;
}

function openOverlayHtml(html) {
  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = html;
}

function computeTotalLevelAndXp() {
  let totalLevel = 0;
  let totalXp = 0;
  for(const skill of SKILL_DISPLAY_ORDER) {
    const state = player.skills?.[skill];
    totalLevel += Number(state?.level || 1);
    totalXp += Number(state?.xp || 0);
  }
  return { totalLevel, totalXp };
}

async function openProfilePanel() {
  if(!player.session_token) {
    registerForArena();
    return;
  }
  const [meRes, stateRes] = await Promise.all([
    apiFetch('/api/v1/character/me').catch(() => null),
    apiFetch('/api/v1/character/state').catch(() => null),
  ]);
  const meData = meRes && meRes.ok ? await meRes.json() : null;
  const stateData = stateRes && stateRes.ok ? await stateRes.json() : null;
  if(meData?.account) {
    player.account_id = meData.account.account_id || player.account_id;
    player.wallet_address = meData.account.wallet_address || player.wallet_address;
    player.actor_type = meData.actor_type || meData.account.account_type || player.actor_type;
    player.character_name = meData.selected_character?.name || player.character_name;
    player.mode = meData.selected_character?.mode || player.mode;
  }
  if(stateData?.progress?.skills) player.skills = stateData.progress.skills;
  if(stateData?.progress?.inventory) player.inventory = stateData.progress.inventory;
  if(stateData?.bank) player.bank = stateData.bank;

  const totals = computeTotalLevelAndXp();
  const tutorialStatus = tutorialState.completed
    ? 'completed'
    : tutorialState.skipped
      ? 'skipped'
      : isTutorialWithinWindow() ? 'active' : 'expired';

  openOverlayHtml(`
    <div style=\"text-align:left;max-height:390px;overflow:auto;min-width:620px\">
      <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px\">
        <div style=\"color:#d4e1ff;font-size:16px\">👤 Profile</div>
        <div style=\"color:#7e91a7;font-size:11px\">Hotkeys: [P] profile · [H] highscores · [C] characters · [Y] nearby · [L] logout</div>
      </div>
      <div style=\"display:grid;grid-template-columns:1fr 1fr;gap:8px\">
        <div style=\"border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)\">
          <div style=\"color:#8fd2ff;font-size:12px;margin-bottom:6px\">Identity</div>
          <div style=\"font-size:11px;color:#b7c5dc;margin-bottom:3px\">Account: ${player.account_id || '-'}</div>
          <div style=\"font-size:11px;color:#b7c5dc;margin-bottom:3px\">Wallet: ${player.wallet_address || '-'}</div>
          <div style=\"font-size:11px;color:#b7c5dc;margin-bottom:3px\">Actor: ${player.actor_type || 'human'}</div>
          <div style=\"font-size:11px;color:#b7c5dc\">Character: ${player.character_name || player.agent_id || '-'}</div>
        </div>
        <div style=\"border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)\">
          <div style=\"color:#8fd2ff;font-size:12px;margin-bottom:6px\">Build</div>
          <div style=\"font-size:11px;color:#b7c5dc;margin-bottom:3px\">Class: ${player.combat_class}</div>
          <div style=\"font-size:11px;color:#b7c5dc;margin-bottom:3px\">Mode: ${player.mode || 'f2p_2007'}</div>
          <div style=\"font-size:11px;color:#b7c5dc;margin-bottom:3px\">Area: ${player.area_id || DEFAULT_AREA_ID}${player.instance_id ? ` (${player.instance_id})` : ''}</div>
          <div style=\"font-size:11px;color:#b7c5dc\">Avatar: ${player.avatar_id || '-'}</div>
        </div>
      </div>
      <div style=\"margin-top:8px;border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)\">
        <div style=\"color:#8fd2ff;font-size:12px;margin-bottom:6px\">Progress Snapshot</div>
        <div style=\"font-size:11px;color:#b7c5dc;margin-bottom:3px\">Total Level: ${totals.totalLevel}</div>
        <div style=\"font-size:11px;color:#b7c5dc;margin-bottom:3px\">Total XP: ${totals.totalXp}</div>
        <div style=\"font-size:11px;color:#b7c5dc\">Tutorial: ${tutorialStatus}</div>
      </div>
      <div style=\"display:flex;gap:6px;flex-wrap:wrap;margin-top:8px\">
        <button onclick=\"window.resumeTutorial()\" style=\"padding:5px 8px;background:#2a4f8a;border:1px solid #4f7cc5;color:#fff;font-size:10px;font-family:monospace;cursor:pointer\">Resume Tutorial</button>
        <button onclick=\"window.openWorldHighscores('pvp')\" style=\"padding:5px 8px;background:#335a66;border:1px solid #4d8d9f;color:#fff;font-size:10px;font-family:monospace;cursor:pointer\">Open Highscores</button>
        <button onclick=\"window.openCharacterPanel()\" style=\"padding:5px 8px;background:#4f4b30;border:1px solid #8a7a44;color:#fff;font-size:10px;font-family:monospace;cursor:pointer\">Manage Characters</button>
        <button onclick=\"window.openNearbyChallengeOverlay()\" style=\"padding:5px 8px;background:#4a355f;border:1px solid #8762a8;color:#fff;font-size:10px;font-family:monospace;cursor:pointer\">Nearby Players</button>
      </div>
      <div style=\"text-align:center;color:#666;font-size:11px;margin-top:8px\">Press Q or P to close</div>
    </div>
  `);
}

const leaderboardUi = {
  tab: 'pvp',
  rows: [],
  skill: '',
  metric: 'xp',
};

async function fetchWorldLeaderboardRows(tab, skill = leaderboardUi.skill, metric = leaderboardUi.metric) {
  if(tab === 'skills') {
    const skillParam = skill ? `&skill=${encodeURIComponent(skill)}` : '';
    const res = await apiFetch(`/api/v1/leaderboards/skills?limit=50&offset=0&metric=${encodeURIComponent(metric)}${skillParam}`);
    const data = await res.json().catch(() => []);
    return { ok: res.ok, data };
  }
  if(tab === 'quests') {
    const res = await apiFetch('/api/v1/leaderboards/quests?limit=50&offset=0');
    const data = await res.json().catch(() => []);
    return { ok: res.ok, data };
  }
  const res = await apiFetch('/api/v1/leaderboards/pvp?limit=50&offset=0');
  const data = await res.json().catch(() => []);
  return { ok: res.ok, data };
}

function renderWorldLeaderboardTable(tab, rows) {
  if(!Array.isArray(rows) || rows.length === 0) {
    return '<div style=\"color:#8896aa;font-size:11px\">No entries yet.</div>';
  }
  if(tab === 'skills') {
    return `<table style=\"width:100%;border-collapse:collapse;font-size:11px\">
      <thead><tr><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">#</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">Character</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">Skill</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">Level</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">XP</th></tr></thead>
      <tbody>${rows.map((row) => `<tr><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.rank}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.character_name}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.skill || 'overall'}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.level}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.xp}</td></tr>`).join('')}</tbody>
    </table>`;
  }
  if(tab === 'quests') {
    return `<table style=\"width:100%;border-collapse:collapse;font-size:11px\">
      <thead><tr><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">#</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">Character</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">Completed</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">Quest Pts</th></tr></thead>
      <tbody>${rows.map((row) => `<tr><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.rank}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.character_name}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.completed_count}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.quest_points}</td></tr>`).join('')}</tbody>
    </table>`;
  }
  return `<table style=\"width:100%;border-collapse:collapse;font-size:11px\">
    <thead><tr><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">#</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">Character</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">Class</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">ELO</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">W-L</th><th style=\"text-align:left;border-bottom:1px solid #3a5272;padding:6px\">KD</th></tr></thead>
    <tbody>${rows.map((row) => `<tr><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.rank}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.character_name}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.combat_class}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.elo}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.wins}-${row.losses}</td><td style=\"padding:6px;border-bottom:1px solid #2d3f59\">${row.kd}</td></tr>`).join('')}</tbody>
  </table>`;
}

window.openWorldHighscores = async function(tab = leaderboardUi.tab) {
  leaderboardUi.tab = tab || 'pvp';
  const metricInput = document.getElementById('world-highscore-metric');
  const skillInput = document.getElementById('world-highscore-skill');
  if(metricInput) leaderboardUi.metric = metricInput.value === 'level' ? 'level' : 'xp';
  if(skillInput) leaderboardUi.skill = (skillInput.value || '').trim();

  const response = await fetchWorldLeaderboardRows(leaderboardUi.tab, leaderboardUi.skill, leaderboardUi.metric);
  if(!response.ok) {
    showFloatingText(response.data?.error || 'Highscores unavailable', '#cc3333');
    return;
  }
  leaderboardUi.rows = response.data || [];

  openOverlayHtml(`
    <div style=\"text-align:left;max-height:390px;overflow:auto;min-width:720px\">
      <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px\">
        <div style=\"color:#d4e1ff;font-size:16px\">🏆 Highscores</div>
        <div style=\"color:#6f809a;font-size:10px\">Landing and in-world boards are unified.</div>
      </div>
      <div style=\"display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px\">
        <button onclick=\"window.openWorldHighscores('pvp')\" style=\"padding:5px 8px;background:${leaderboardUi.tab === 'pvp' ? '#2a4f8a' : '#1a2b42'};border:1px solid #4f7cc5;color:#fff;font-size:10px;font-family:monospace;cursor:pointer\">PvP ELO</button>
        <button onclick=\"window.openWorldHighscores('skills')\" style=\"padding:5px 8px;background:${leaderboardUi.tab === 'skills' ? '#2a4f8a' : '#1a2b42'};border:1px solid #4f7cc5;color:#fff;font-size:10px;font-family:monospace;cursor:pointer\">Skills</button>
        <button onclick=\"window.openWorldHighscores('quests')\" style=\"padding:5px 8px;background:${leaderboardUi.tab === 'quests' ? '#2a4f8a' : '#1a2b42'};border:1px solid #4f7cc5;color:#fff;font-size:10px;font-family:monospace;cursor:pointer\">Quest Completion</button>
      </div>
      ${leaderboardUi.tab === 'skills' ? `
        <div style=\"display:grid;grid-template-columns:1fr 160px auto;gap:6px;align-items:center;margin-bottom:8px\">
          <input id=\"world-highscore-skill\" value=\"${leaderboardUi.skill || ''}\" placeholder=\"skill (optional)\" style=\"padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px\" />
          <select id=\"world-highscore-metric\" style=\"padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px\">
            <option value=\"xp\" ${leaderboardUi.metric === 'xp' ? 'selected' : ''}>xp</option>
            <option value=\"level\" ${leaderboardUi.metric === 'level' ? 'selected' : ''}>level</option>
          </select>
          <button onclick=\"window.openWorldHighscores('skills')\" style=\"padding:5px 8px;background:#335a66;border:1px solid #4d8d9f;color:#fff;font-size:10px;font-family:monospace;cursor:pointer\">Refresh</button>
        </div>` : ''}
      <div style=\"overflow:auto\">${renderWorldLeaderboardTable(leaderboardUi.tab, leaderboardUi.rows)}</div>
      <div style=\"text-align:center;color:#666;font-size:11px;margin-top:8px\">Press Q or H to close</div>
    </div>
  `);
};

window.openCharacterPanel = async function() {
  if(!player.session_token) {
    registerForArena();
    return;
  }
  const res = await apiFetch('/api/v1/character/me');
  const data = await res.json().catch(() => ({}));
  if(!res.ok) {
    showFloatingText(data.error || 'Character panel unavailable', '#cc3333');
    return;
  }

  const chars = Array.isArray(data.characters) ? data.characters : [];
  player.actor_type = data.actor_type || data.account?.account_type || player.actor_type;
  player.account_id = data.account?.account_id || player.account_id;
  player.wallet_address = data.account?.wallet_address || player.wallet_address;
  const selectedId = data.selected_character?.character_id || player.agent_id;

  openOverlayHtml(`
    <div style=\"text-align:left;max-height:390px;overflow:auto;min-width:700px\">
      <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px\">
        <div style=\"color:#d4e1ff;font-size:16px\">🧬 Characters</div>
        <div style=\"color:#8a99ad;font-size:11px\">Slots ${chars.length}/3</div>
      </div>
      <div style=\"display:grid;grid-template-columns:1fr;gap:6px;margin-bottom:8px\">
        ${chars.map((ch) => `
          <div style=\"border:1px solid ${ch.character_id === selectedId ? '#5f87c8' : '#33495d'};padding:7px;background:rgba(12,14,20,.84);display:flex;justify-content:space-between;gap:8px;align-items:center\">
            <div>
              <div style=\"font-size:12px;color:#d8e4ff\">${ch.name}</div>
              <div style=\"font-size:10px;color:#8798af\">${ch.combat_class} · ${ch.mode}</div>
            </div>
            <button onclick=\"window.selectCharacterFromMenu('${ch.character_id}')\" style=\"padding:4px 8px;background:#2a4f8a;border:1px solid #4b79c8;color:#fff;font-size:10px;font-family:monospace;cursor:pointer\">${ch.character_id === selectedId ? 'Selected' : 'Select'}</button>
          </div>
        `).join('')}
      </div>
      <div style=\"display:grid;grid-template-columns:1fr auto;gap:6px;align-items:center\">
        <input id=\"menu-new-character-name\" placeholder=\"new character name\" style=\"padding:6px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px\" />
        <button onclick=\"window.createCharacterFromMenu()\" ${chars.length >= 3 ? 'disabled' : ''} style=\"padding:6px 8px;background:#4f4b30;border:1px solid #8a7a44;color:#fff;font-size:10px;font-family:monospace;cursor:pointer\">Create + Select</button>
      </div>
      <div style=\"text-align:center;color:#666;font-size:11px;margin-top:8px\">Press Q or C to close</div>
    </div>
  `);
};

window.selectCharacterFromMenu = async function(characterId) {
  if(!player.session_token || !characterId) return;
  const res = await apiFetch('/api/v1/character/select', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ character_id: characterId }),
  });
  const data = await res.json().catch(() => ({}));
  if(!res.ok) {
    showFloatingText(data.error || 'Character select failed', '#cc3333');
    return;
  }
  player.session_token = data.session_token || player.session_token;
  player.agent_id = data.character?.character_id || player.agent_id;
  player.character_name = data.character?.name || player.character_name;
  player.combat_class = data.character?.combat_class || player.combat_class;
  player.mode = data.character?.mode || player.mode;
  player.avatar_id = DEFAULT_PLAYER_SPRITES[player.combat_class] || player.avatar_id;
  saveStoredAuth();

  await apiFetch('/api/v1/arena/register/self', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ combat_class: player.combat_class, avatar_id: player.avatar_id }),
  }).catch(() => null);

  hydrateTutorialState(player.agent_id);
  await loadCharacterState();
  connectWorldSocket();
  sendWorldUpdate(true);
  await fetchResourceNodes();
  await loadQuestJournal();
  showFloatingText('Character switched', '#66d4ff');
  window.openCharacterPanel();
};

window.createCharacterFromMenu = async function() {
  if(!player.session_token) return;
  const input = document.getElementById('menu-new-character-name');
  const name = (input?.value || '').trim();
  if(!name) {
    showFloatingText('Name required', '#cc3333');
    return;
  }
  const res = await apiFetch('/api/v1/character/create', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ name, combat_class: player.combat_class, select: true }),
  });
  const data = await res.json().catch(() => ({}));
  if(!res.ok) {
    showFloatingText(data.error || 'Character create failed', '#cc3333');
    return;
  }
  if(data.session_token) player.session_token = data.session_token;
  if(data.character?.character_id) {
    player.agent_id = data.character.character_id;
    player.character_name = data.character.name || player.character_name;
    player.combat_class = data.character.combat_class || player.combat_class;
    player.mode = data.character.mode || player.mode;
    player.avatar_id = DEFAULT_PLAYER_SPRITES[player.combat_class] || player.avatar_id;
  }
  saveStoredAuth();
  await apiFetch('/api/v1/arena/register/self', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ combat_class: player.combat_class, avatar_id: player.avatar_id }),
  }).catch(() => null);
  hydrateTutorialState(player.agent_id);
  await loadCharacterState();
  connectWorldSocket();
  sendWorldUpdate(true);
  await fetchResourceNodes();
  await loadQuestJournal();
  showFloatingText('Character created', '#66d4ff');
  window.openCharacterPanel();
};

async function logoutToLanding() {
  if(player.session_token) {
    await apiFetch('/api/v1/auth/logout', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ session_token: player.session_token }),
    }).catch(() => null);
  }
  leaveWorldPresence();
  clearStoredAuth();
  window.location.href = '/';
}

function wirePersistentMenu() {
  if(!persistentMenuEl) return;
  document.getElementById('menu-profile').onclick = () => openProfilePanel();
  document.getElementById('menu-highscores').onclick = () => window.openWorldHighscores('pvp');
  document.getElementById('menu-characters').onclick = () => window.openCharacterPanel();
  document.getElementById('menu-nearby').onclick = () => window.openNearbyChallengeOverlay();
  document.getElementById('menu-logout').onclick = () => logoutToLanding();
  document.getElementById('menu-agent-console').onclick = () => { window.location.href = '/agent-console.html'; };
  updateNearbyMenuLabel();
}

function requireSessionForEconomy() {
  if(player.session_token) return true;
  showFloatingText('Wallet session required. Press [F] to register.', '#cc3333');
  registerForArena();
  return false;
}

function openInventoryOverlay() {
  if(!player.agent_id) {
    registerForArena();
    return;
  }

  const entries = Object.entries(player.inventory || {})
    .filter(([, qty]) => Number(qty) > 0)
    .sort((a, b) => Number(b[1]) - Number(a[1]));
  const equipment = player.equipment || {};
  const questIcon = getGeneratedAssetPath('ui_quest_icon');
  const spellIcon = getGeneratedAssetPath('ui_spellbook_icon');
  const tradeIcon = getGeneratedAssetPath('ui_trade_icon');

  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = `
    <div style="text-align:left;max-height:390px;overflow:auto;min-width:560px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="color:#d4e1ff;font-size:16px">🎒 Inventory & Equipment</div>
        <div style="display:flex;gap:6px;align-items:center">
          ${spellIcon ? `<img src="${spellIcon}" style="width:16px;height:16px;image-rendering:pixelated" />` : ''}
          ${questIcon ? `<img src="${questIcon}" style="width:16px;height:16px;image-rendering:pixelated" />` : ''}
          ${tradeIcon ? `<img src="${tradeIcon}" style="width:16px;height:16px;image-rendering:pixelated" />` : ''}
        </div>
      </div>
      <div style="color:#8d95a6;font-size:11px;margin-bottom:8px">Agent: ${player.agent_id} · Class: ${player.combat_class}</div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
        <div style="border:1px solid #334;padding:8px;background:rgba(10,14,18,.82)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Equipment</div>
          ${Object.entries(equipment).map(([slot, item]) =>
            `<div style="display:flex;justify-content:space-between;font-size:11px;color:#b7c5dc;margin-bottom:2px">
              <span>${slot}</span><span>${item ? renderItemInline(item, null) : '-'}</span>
            </div>`
          ).join('')}
        </div>
        <div style="border:1px solid #334;padding:8px;background:rgba(10,14,18,.82)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Inventory</div>
          ${entries.slice(0, 24).map(([itemId, qty]) =>
            `<div style="display:flex;justify-content:space-between;font-size:11px;color:#b7c5dc;margin-bottom:2px">
              <span>${renderItemInline(itemId, null)}</span><span style="color:#d4a017">${qty}</span>
            </div>`
          ).join('') || '<div style="font-size:11px;color:#778">Inventory is empty</div>'}
        </div>
      </div>
      <div style="color:#7e91a7;font-size:11px;margin-top:8px">Hotkeys: [J] quests · [N] bank · [T] trade · [G] grand exchange</div>
      <div style="text-align:center;color:#666;font-size:11px;margin-top:8px">Press Q or I to close</div>
    </div>`;
}

async function openQuestLogOverlay() {
  if(!player.agent_id) {
    registerForArena();
    return;
  }
  await loadQuestJournal();
  const quests = Array.isArray(questLog) ? [...questLog] : [];
  quests.sort((a, b) => a.name.localeCompare(b.name));
  const questIcon = getGeneratedAssetPath('ui_quest_icon');

  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = `
    <div style="text-align:left;max-height:390px;overflow:auto;min-width:640px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="color:#d4e1ff;font-size:16px">📜 Quest Journal</div>
        ${questIcon ? `<img src="${questIcon}" style="width:18px;height:18px;image-rendering:pixelated" />` : ''}
      </div>
      <div style="color:#8d95a6;font-size:11px;margin-bottom:8px">Canonical 2007 F2P quests: ${quests.length}</div>
      <div style="display:grid;grid-template-columns:1fr;gap:6px">
        ${quests.map((quest) => {
          const objective = quest.objectives.find((entry) => !entry.complete) || quest.objectives[quest.active_objective_index] || quest.objectives[0];
          const statusColor = quest.status === 'completed' ? '#d4a017' : quest.status === 'in_progress' ? '#66d4ff' : '#9aa7b8';
          const startBtn = quest.status === 'not_started' ? `<button onclick="questAction('start','${quest.quest_id}')" style="padding:4px 8px;background:#2a4f8a;border:1px solid #4b79c8;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Start</button>` : '';
          const advanceBtn = quest.status === 'in_progress' ? `<button onclick="questAction('advance','${quest.quest_id}')" style="padding:4px 8px;background:#335a66;border:1px solid #4d8d9f;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Advance</button>` : '';
          const claimBtn = quest.status === 'completed' && !quest.reward_claimed ? `<button onclick="questAction('claim','${quest.quest_id}')" style="padding:4px 8px;background:#6c5a20;border:1px solid #a88a33;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Claim Reward</button>` : '';
          return `<div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)">
            <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:8px">
              <div>
                <div style="color:#d8e4ff;font-size:12px">${quest.name}</div>
                <div style="color:${statusColor};font-size:11px">${quest.status}${quest.reward_claimed ? ' · reward claimed' : ''}</div>
                <div style="color:#8a99ad;font-size:10px;margin-top:3px">${objective ? objective.description : quest.description}</div>
              </div>
              <div style="display:flex;gap:4px;flex-wrap:wrap;justify-content:flex-end">${startBtn}${advanceBtn}${claimBtn}</div>
            </div>
          </div>`;
        }).join('')}
      </div>
      <div style="text-align:center;color:#666;font-size:11px;margin-top:8px">Press Q or J to close</div>
    </div>`;
  markTutorialGoal('open_quest_log');
}

window.questAction = async function(action, questId) {
  if(!requireSessionForEconomy()) return;
  const routeByAction = {
    start: '/api/v1/quests/start',
    advance: '/api/v1/quests/advance',
    claim: '/api/v1/quests/claim',
  };
  const endpoint = routeByAction[action];
  if(!endpoint) return;

  try {
    const payload = action === 'advance' ? { quest_id: questId } : { quest_id: questId };
    const res = await apiFetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Quest action failed', '#cc3333');
      return;
    }
    if(Array.isArray(data.quests)) {
      questLog = data.quests;
    }
    if(data.skills) {
      player.skills = data.skills;
    }
    if(data.inventory) {
      player.inventory = data.inventory;
    }
    showFloatingText(`Quest ${action}`, '#66d4ff');
    await openQuestLogOverlay();
  } catch {
    showFloatingText('Quest action failed', '#cc3333');
  }
};

async function refreshBankState() {
  if(!requireSessionForEconomy()) return false;
  const res = await apiFetch('/api/v1/character/state');
  if(!res.ok) return false;
  const data = await res.json();
  player.inventory = data.progress?.inventory || player.inventory;
  player.bank = data.bank || player.bank || {};
  if(Array.isArray(data.quests)) {
    questLog = data.quests;
  }
  return true;
}

async function openBankOverlay() {
  if(!await refreshBankState()) return;

  const invEntries = Object.entries(player.inventory || {})
    .filter(([, qty]) => Number(qty) > 0)
    .sort((a, b) => Number(b[1]) - Number(a[1]));
  const bankEntries = Object.entries(player.bank || {})
    .filter(([, qty]) => Number(qty) > 0)
    .sort((a, b) => Number(b[1]) - Number(a[1]));

  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = `
    <div style="text-align:left;max-height:390px;overflow:auto;min-width:680px">
      <div style="color:#d4e1ff;font-size:16px;margin-bottom:8px">🏦 Bank</div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
        <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Inventory</div>
          ${invEntries.slice(0, 30).map(([itemId, qty]) =>
            `<div style="display:flex;justify-content:space-between;align-items:center;font-size:11px;color:#b7c5dc;margin-bottom:2px">
              <span>${renderItemInline(itemId, qty)}</span>
              <button onclick="bankDepositItem('${escJs(itemId)}', 1)" style="padding:2px 6px;background:#234a3d;border:1px solid #3b826c;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Deposit 1</button>
            </div>`
          ).join('') || '<div style="font-size:11px;color:#778">No items to deposit</div>'}
        </div>
        <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Bank</div>
          ${bankEntries.slice(0, 30).map(([itemId, qty]) =>
            `<div style="display:flex;justify-content:space-between;align-items:center;font-size:11px;color:#b7c5dc;margin-bottom:2px">
              <span>${renderItemInline(itemId, qty)}</span>
              <button onclick="bankWithdrawItem('${escJs(itemId)}', 1)" style="padding:2px 6px;background:#3d2f5f;border:1px solid #6e57a5;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Withdraw 1</button>
            </div>`
          ).join('') || '<div style="font-size:11px;color:#778">Bank is empty</div>'}
        </div>
      </div>
      <div style="text-align:center;color:#666;font-size:11px;margin-top:8px">Press Q or N to close</div>
    </div>`;
}

window.bankDepositItem = async function(itemId, qty) {
  if(!requireSessionForEconomy()) return;
  try {
    const res = await apiFetch('/api/v1/economy/bank/deposit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ item_id: itemId, qty }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Deposit failed', '#cc3333');
      return;
    }
    player.inventory = data.inventory || player.inventory;
    player.bank = data.bank || player.bank;
    await openBankOverlay();
  } catch {
    showFloatingText('Deposit failed', '#cc3333');
  }
};

window.bankWithdrawItem = async function(itemId, qty) {
  if(!requireSessionForEconomy()) return;
  try {
    const res = await apiFetch('/api/v1/economy/bank/withdraw', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ item_id: itemId, qty }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Withdraw failed', '#cc3333');
      return;
    }
    player.inventory = data.inventory || player.inventory;
    player.bank = data.bank || player.bank;
    await openBankOverlay();
  } catch {
    showFloatingText('Withdraw failed', '#cc3333');
  }
};

function getNearbyAgentRows() {
  return [...worldAgents.values()]
    .filter((agent) => isSameShard(agent.area_id, agent.instance_id))
    .map((agent) => {
      const dx = Number(agent.x || 0) - Number(player.x || 0);
      const dy = Number(agent.y || 0) - Number(player.y || 0);
      const distance = Math.round(Math.hypot(dx, dy));
      return {
        ...agent,
        distance,
      };
    })
    .sort((a, b) => a.distance - b.distance || String(a.agent_id).localeCompare(String(b.agent_id)));
}

function updateNearbyMenuLabel() {
  const menuButton = document.getElementById('menu-nearby');
  if(!menuButton) return;
  const incomingCount = challengeUi.pending.filter(
    (entry) => entry.status === 'pending' && entry.target_id === player.agent_id
  ).length;
  menuButton.textContent = incomingCount > 0 ? `Nearby (${incomingCount})` : 'Nearby';
}

async function refreshChallengeState() {
  if(!player.agent_id) {
    challengeUi.pending = [];
    updateNearbyMenuLabel();
    return false;
  }
  try {
    const res = await apiFetch(`/api/v1/arena/challenges/${encodeURIComponent(player.agent_id)}`);
    if(!res.ok) {
      challengeUi.pending = [];
      updateNearbyMenuLabel();
      return false;
    }
    const data = await res.json().catch(() => []);
    challengeUi.pending = Array.isArray(data) ? data : [];
    updateNearbyMenuLabel();
    return true;
  } catch {
    challengeUi.pending = [];
    updateNearbyMenuLabel();
    return false;
  }
}

async function openNearbyChallengeOverlay() {
  if(!player.agent_id) {
    registerForArena();
    return;
  }
  await refreshChallengeState();
  const nearby = getNearbyAgentRows();
  const incoming = challengeUi.pending
    .filter((entry) => entry.status === 'pending' && entry.target_id === player.agent_id)
    .sort((a, b) => Number(b.created_at || 0) - Number(a.created_at || 0));
  const outgoing = challengeUi.pending
    .filter((entry) => entry.status === 'pending' && entry.challenger_id === player.agent_id)
    .sort((a, b) => Number(b.created_at || 0) - Number(a.created_at || 0));

  openOverlayHtml(`
    <div style="text-align:left;max-height:390px;overflow:auto;min-width:760px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="color:#d4e1ff;font-size:16px">⚔ Nearby Players</div>
        <div style="color:#8a99ad;font-size:11px">Direct challenge flow</div>
      </div>
      <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84);margin-bottom:8px">
        <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Challenge a nearby player</div>
        <div style="display:grid;grid-template-columns:1fr 120px 120px auto;gap:6px;align-items:center">
          <select id="challenge-target" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px">
            ${nearby.map((agent) => `<option value="${agent.agent_id}">${agent.agent_id} · ${agent.combat_class || 'unknown'} · ${agent.distance}px</option>`).join('') || '<option value="">No nearby players</option>'}
          </select>
          <select id="challenge-arena" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px">
            <option value="duel_arena">duel_arena</option>
            <option value="pit">pit</option>
            <option value="mage_tower">mage_tower</option>
          </select>
          <input id="challenge-wager" type="number" min="0" value="0" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px" />
          <button onclick="window.sendNearbyChallenge()" style="padding:6px;background:#2a4f8a;border:1px solid #4b79c8;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Send</button>
        </div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
        <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Incoming Challenges</div>
          ${incoming.map((entry) => `
            <div style="border:1px solid #2c3a4f;padding:6px;margin-bottom:4px">
              <div style="font-size:11px;color:#d4e1ff">${entry.challenger_id} challenged you</div>
              <div style="font-size:10px;color:#8a99ad">Arena: ${entry.arena} · Wager: ${entry.wager_amount || 0}</div>
              <div style="display:flex;gap:4px;margin-top:4px">
                <button onclick="window.acceptNearbyChallenge('${entry.challenge_id}')" style="padding:3px 6px;background:#2c6c4a;border:1px solid #48a66d;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Accept</button>
                <button onclick="window.declineNearbyChallenge('${entry.challenge_id}')" style="padding:3px 6px;background:#7a2f2f;border:1px solid #b65151;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Decline</button>
              </div>
            </div>
          `).join('') || '<div style="font-size:11px;color:#778">No incoming challenges</div>'}
        </div>
        <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Outgoing Challenges</div>
          ${outgoing.map((entry) => `
            <div style="border:1px solid #2c3a4f;padding:6px;margin-bottom:4px">
              <div style="font-size:11px;color:#d4e1ff">you → ${entry.target_id}</div>
              <div style="font-size:10px;color:#8a99ad">Arena: ${entry.arena} · Wager: ${entry.wager_amount || 0}</div>
              <div style="font-size:10px;color:#8a99ad;margin-top:3px">Waiting for response...</div>
            </div>
          `).join('') || '<div style="font-size:11px;color:#778">No outgoing challenges</div>'}
        </div>
      </div>
      <div style="text-align:center;color:#666;font-size:11px;margin-top:8px">Press Q or Y to close</div>
    </div>`);
}
window.openNearbyChallengeOverlay = openNearbyChallengeOverlay;

window.sendNearbyChallenge = async function() {
  if(!player.agent_id) return;
  const targetAgentId = document.getElementById('challenge-target')?.value || '';
  const arena = document.getElementById('challenge-arena')?.value || 'duel_arena';
  const wagerAmount = Math.max(0, Number(document.getElementById('challenge-wager')?.value || 0));
  if(!targetAgentId) {
    showFloatingText('No nearby target selected', '#cc3333');
    return;
  }
  try {
    const res = await apiFetch('/api/v1/arena/challenge', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        agent_id: player.agent_id,
        target_agent_id: targetAgentId,
        arena,
        wager_amount: wagerAmount,
      }),
    });
    const data = await res.json().catch(() => ({}));
    if(!res.ok) {
      showFloatingText(data.error || 'Challenge failed', '#cc3333');
      return;
    }
    showFloatingText(`Challenge sent to ${targetAgentId}`, '#66d4ff');
    await openNearbyChallengeOverlay();
  } catch {
    showFloatingText('Challenge failed', '#cc3333');
  }
};

window.acceptNearbyChallenge = async function(challengeId) {
  if(!player.agent_id || !challengeId) return;
  try {
    const res = await apiFetch('/api/v1/arena/accept', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        agent_id: player.agent_id,
        challenge_id: challengeId,
      }),
    });
    const data = await res.json().catch(() => ({}));
    if(!res.ok) {
      showFloatingText(data.error || 'Accept failed', '#cc3333');
      return;
    }
    closeCombatOverlay();
    await refreshChallengeState();
    if(data.fight_id) {
      startArenaFightFromMatch(data.fight_id);
    }
  } catch {
    showFloatingText('Accept failed', '#cc3333');
  }
};

window.declineNearbyChallenge = async function(challengeId) {
  if(!player.agent_id || !challengeId) return;
  try {
    const res = await apiFetch('/api/v1/arena/decline', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        agent_id: player.agent_id,
        challenge_id: challengeId,
      }),
    });
    const data = await res.json().catch(() => ({}));
    if(!res.ok) {
      showFloatingText(data.error || 'Decline failed', '#cc3333');
      return;
    }
    showFloatingText('Challenge declined', '#d4a017');
    await openNearbyChallengeOverlay();
  } catch {
    showFloatingText('Decline failed', '#cc3333');
  }
};

async function refreshTradeState() {
  if(!requireSessionForEconomy()) return false;
  const res = await apiFetch('/api/v1/economy/trade/pending');
  if(!res.ok) return false;
  const data = await res.json();
  economyUi.trades = {
    incoming: data.incoming || [],
    outgoing: data.outgoing || [],
  };
  return true;
}

async function openTradeOverlay() {
  if(!await refreshTradeState()) return;
  const nearby = [...worldAgents.values()]
    .filter((agent) => isSameShard(agent.area_id, agent.instance_id))
    .sort((a, b) => String(a.agent_id).localeCompare(String(b.agent_id)));
  const tradeIcon = getGeneratedAssetPath('ui_trade_icon');

  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = `
    <div style="text-align:left;max-height:390px;overflow:auto;min-width:700px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="color:#d4e1ff;font-size:16px">🤝 Player Trade</div>
        ${tradeIcon ? `<img src="${tradeIcon}" style="width:18px;height:18px;image-rendering:pixelated" />` : ''}
      </div>
      <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84);margin-bottom:8px">
        <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Create Trade Request</div>
        <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr 1fr;gap:6px;align-items:center">
          <select id="trade-target" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px">
            ${nearby.map((agent) => `<option value="${agent.agent_id}">${agent.agent_id}</option>`).join('') || '<option value="">No nearby players</option>'}
          </select>
          <input id="trade-offer-item" value="logs" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px" />
          <input id="trade-offer-qty" type="number" min="1" value="1" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px" />
          <input id="trade-request-item" value="coins" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px" />
          <button onclick="submitTradeRequest()" style="padding:6px;background:#2a4f8a;border:1px solid #4b79c8;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Send</button>
        </div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
        <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Incoming</div>
          ${economyUi.trades.incoming.map((offer) => `
            <div style="border:1px solid #2c3a4f;padding:6px;margin-bottom:4px">
              <div style="font-size:11px;color:#b7c5dc">${offer.from_character_id} → you (${offer.status})</div>
              <div style="font-size:10px;color:#8a99ad;display:flex;flex-wrap:wrap;gap:6px">Offer: ${Object.entries(offer.offered_items || {}).map(([k,v]) => renderItemInline(k, v)).join('') || 'none'}</div>
              <div style="font-size:10px;color:#8a99ad;display:flex;flex-wrap:wrap;gap:6px">Request: ${Object.entries(offer.requested_items || {}).map(([k,v]) => renderItemInline(k, v)).join('') || 'none'}</div>
              <div style="display:flex;gap:4px;margin-top:4px">
                ${offer.status === 'pending' ? `<button onclick="respondTrade('${offer.trade_id}','accept')" style="padding:3px 6px;background:#2c6c4a;border:1px solid #48a66d;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Accept</button>
                <button onclick="respondTrade('${offer.trade_id}','decline')" style="padding:3px 6px;background:#7a2f2f;border:1px solid #b65151;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Decline</button>` : ''}
                ${offer.status === 'accepted' ? `<button onclick="confirmTrade('${offer.trade_id}')" style="padding:3px 6px;background:#38508c;border:1px solid #5b7bcf;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Confirm</button>` : ''}
              </div>
            </div>
          `).join('') || '<div style="font-size:11px;color:#778">No incoming trades</div>'}
        </div>
        <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Outgoing</div>
          ${economyUi.trades.outgoing.map((offer) => `
            <div style="border:1px solid #2c3a4f;padding:6px;margin-bottom:4px">
              <div style="font-size:11px;color:#b7c5dc">you → ${offer.to_character_id} (${offer.status})</div>
              <div style="font-size:10px;color:#8a99ad;display:flex;flex-wrap:wrap;gap:6px">Offer: ${Object.entries(offer.offered_items || {}).map(([k,v]) => renderItemInline(k, v)).join('') || 'none'}</div>
              <div style="font-size:10px;color:#8a99ad;display:flex;flex-wrap:wrap;gap:6px">Request: ${Object.entries(offer.requested_items || {}).map(([k,v]) => renderItemInline(k, v)).join('') || 'none'}</div>
              ${offer.status === 'accepted' ? `<button onclick="confirmTrade('${offer.trade_id}')" style="margin-top:4px;padding:3px 6px;background:#38508c;border:1px solid #5b7bcf;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Confirm</button>` : ''}
            </div>
          `).join('') || '<div style="font-size:11px;color:#778">No outgoing trades</div>'}
        </div>
      </div>
      <div style="text-align:center;color:#666;font-size:11px;margin-top:8px">Press Q or T to close</div>
    </div>`;
}

window.submitTradeRequest = async function() {
  if(!requireSessionForEconomy()) return;
  const toCharacterId = document.getElementById('trade-target')?.value || '';
  const offeredItem = (document.getElementById('trade-offer-item')?.value || '').trim();
  const offeredQty = Math.max(1, Number(document.getElementById('trade-offer-qty')?.value || 1));
  const requestedItem = (document.getElementById('trade-request-item')?.value || '').trim();
  if(!toCharacterId || !offeredItem || !requestedItem) {
    showFloatingText('Set target + trade items', '#cc3333');
    return;
  }

  try {
    const res = await apiFetch('/api/v1/economy/trade/request', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        to_character_id: toCharacterId,
        offered_items: { [offeredItem]: offeredQty },
        requested_items: { [requestedItem]: 1 },
      }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Trade request failed', '#cc3333');
      return;
    }
    showFloatingText('Trade request sent', '#66d4ff');
    await openTradeOverlay();
  } catch {
    showFloatingText('Trade request failed', '#cc3333');
  }
};

window.respondTrade = async function(tradeId, decision) {
  if(!requireSessionForEconomy()) return;
  try {
    const res = await apiFetch('/api/v1/economy/trade/respond', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ trade_id: tradeId, decision }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Trade response failed', '#cc3333');
      return;
    }
    showFloatingText(`Trade ${data.status}`, '#66d4ff');
    await openTradeOverlay();
  } catch {
    showFloatingText('Trade response failed', '#cc3333');
  }
};

window.confirmTrade = async function(tradeId) {
  if(!requireSessionForEconomy()) return;
  try {
    const res = await apiFetch('/api/v1/economy/trade/confirm', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ trade_id: tradeId }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Trade confirm failed', '#cc3333');
      return;
    }
    await loadCharacterState();
    showFloatingText('Trade completed', '#66d4ff');
    await openTradeOverlay();
  } catch {
    showFloatingText('Trade confirm failed', '#cc3333');
  }
};

async function refreshGeState(itemId = economyUi.ge_item) {
  if(!requireSessionForEconomy()) return false;
  economyUi.ge_item = itemId || economyUi.ge_item || DEFAULT_GE_ITEM;
  const [bookRes, myRes] = await Promise.all([
    apiFetch(`/api/v1/economy/ge/book/${encodeURIComponent(economyUi.ge_item)}`),
    apiFetch('/api/v1/economy/ge/my'),
  ]);
  if(bookRes.ok) {
    const book = await bookRes.json();
    economyUi.ge_book = { buys: book.buys || [], sells: book.sells || [] };
  }
  if(myRes.ok) {
    const mine = await myRes.json();
    economyUi.ge_orders = mine.orders || [];
  }
  return true;
}

async function openGrandExchangeOverlay() {
  if(!await refreshGeState(economyUi.ge_item || DEFAULT_GE_ITEM)) return;
  registrationOpen = true;
  combatOverlay.style.display = 'block';
  combatOverlay.innerHTML = `
    <div style="text-align:left;max-height:390px;overflow:auto;min-width:760px">
      <div style="color:#d4e1ff;font-size:16px;margin-bottom:8px">💰 Grand Exchange</div>
      <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84);margin-bottom:8px">
        <div style="display:grid;grid-template-columns:2fr 1fr 1fr 1fr 1fr;gap:6px;align-items:center">
          <input id="ge-item" value="${economyUi.ge_item}" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px" />
          <select id="ge-side" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px">
            <option value="buy">buy</option>
            <option value="sell">sell</option>
          </select>
          <input id="ge-qty" type="number" min="1" value="1" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px" />
          <input id="ge-price" type="number" min="1" value="100" style="padding:5px;background:#121723;border:1px solid #33495d;color:#c1d2e7;font-family:monospace;font-size:11px" />
          <button onclick="createGeOrder()" style="padding:6px;background:#2a4f8a;border:1px solid #4b79c8;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Create</button>
        </div>
        <div style="margin-top:6px">
          <button onclick="loadGeBook()" style="padding:5px 8px;background:#30445c;border:1px solid #466587;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Refresh Book</button>
        </div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px">
        <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Buy Orders</div>
          ${economyUi.ge_book.buys.slice(0, 20).map((order) =>
            `<div style="font-size:10px;color:#b7c5dc;margin-bottom:2px;display:flex;justify-content:space-between">${renderItemInline(order.item_id, order.qty - order.filled_qty)} <span>${order.price_each} gp</span></div>`
          ).join('') || '<div style="font-size:11px;color:#778">No buys</div>'}
        </div>
        <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">Sell Orders</div>
          ${economyUi.ge_book.sells.slice(0, 20).map((order) =>
            `<div style="font-size:10px;color:#b7c5dc;margin-bottom:2px;display:flex;justify-content:space-between">${renderItemInline(order.item_id, order.qty - order.filled_qty)} <span>${order.price_each} gp</span></div>`
          ).join('') || '<div style="font-size:11px;color:#778">No sells</div>'}
        </div>
        <div style="border:1px solid #334;padding:8px;background:rgba(12,14,20,.84)">
          <div style="color:#8fd2ff;font-size:12px;margin-bottom:6px">My Orders</div>
          ${economyUi.ge_orders.slice(0, 20).map((order) => `
            <div style="border:1px solid #2c3a4f;padding:5px;margin-bottom:4px">
              <div style="font-size:10px;color:#b7c5dc;display:flex;justify-content:space-between">${renderItemInline(order.item_id, null)} <span>${order.side} @ ${order.price_each} gp</span></div>
              <div style="font-size:10px;color:#8a99ad">${order.filled_qty}/${order.qty} · ${order.status}</div>
              ${(order.status === 'open' || order.status === 'partially_filled')
                ? `<button onclick="cancelGeOrder('${order.order_id}')" style="margin-top:3px;padding:3px 6px;background:#7a2f2f;border:1px solid #b65151;color:#fff;font-size:10px;font-family:monospace;cursor:pointer">Cancel</button>`
                : ''}
            </div>
          `).join('') || '<div style="font-size:11px;color:#778">No orders</div>'}
        </div>
      </div>
      <div style="text-align:center;color:#666;font-size:11px;margin-top:8px">Press Q or G to close</div>
    </div>`;
}

window.loadGeBook = async function() {
  const item = (document.getElementById('ge-item')?.value || '').trim();
  if(item) economyUi.ge_item = item;
  await openGrandExchangeOverlay();
};

window.createGeOrder = async function() {
  if(!requireSessionForEconomy()) return;
  const item = (document.getElementById('ge-item')?.value || '').trim();
  const side = document.getElementById('ge-side')?.value === 'sell' ? 'sell' : 'buy';
  const qty = Math.max(1, Number(document.getElementById('ge-qty')?.value || 1));
  const price = Math.max(1, Number(document.getElementById('ge-price')?.value || 1));
  if(!item) {
    showFloatingText('Item id required', '#cc3333');
    return;
  }

  try {
    const res = await apiFetch('/api/v1/economy/ge/order', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ item_id: item, side, qty, price_each: price }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'GE order failed', '#cc3333');
      return;
    }
    await loadCharacterState();
    economyUi.ge_item = item;
    showFloatingText('GE order created', '#66d4ff');
    await openGrandExchangeOverlay();
  } catch {
    showFloatingText('GE order failed', '#cc3333');
  }
};

window.cancelGeOrder = async function(orderId) {
  if(!requireSessionForEconomy()) return;
  try {
    const res = await apiFetch(`/api/v1/economy/ge/order/${encodeURIComponent(orderId)}`, {
      method: 'DELETE',
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Cancel failed', '#cc3333');
      return;
    }
    await loadCharacterState();
    showFloatingText('Order cancelled', '#66d4ff');
    await openGrandExchangeOverlay();
  } catch {
    showFloatingText('Cancel failed', '#cc3333');
  }
};

async function startArenaFightFromMatch(fightId) {
  if(!fightId || !player.agent_id) return;
  try {
    if(skillActionNodeId) {
      apiFetch('/api/v1/world/interact', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({agent_id:player.agent_id,node_id:skillActionNodeId,action:'stop'})
      }).catch(()=>{});
      skillActionNodeId = null;
    }

    const res = await apiFetch(API + '/fight/' + fightId);
    if(!res.ok) return;
    const fight = await res.json();

    const isP1 = fight.p1.agent_id === player.agent_id;
    const opponentState = isP1 ? fight.p2 : fight.p1;
    const selfState = isP1 ? fight.p1 : fight.p2;

    player.inFight = true;
    worldReturnPoint = {
      x: player.x,
      y: player.y,
      area_id: player.area_id || DEFAULT_AREA_ID,
      instance_id: player.instance_id || null,
    };
    leaveWorldPresence();

    arenaFight = {
      fight_id: fightId,
      opponent: {
        id: opponentState.agent_id,
        class: opponentState.combat_class,
        hp: opponentState.hp,
        maxHp: 99,
        prayer: opponentState.prayer,
        maxPrayer: 99,
        x: 10800,
        y: GROUND_Y,
        facing: -1,
      },
      playerSlot: isP1 ? 'p1' : 'p2',
      tick: fight.tick || 0,
      tickWindowMs: fight.tick_window_ms || 600,
      nextTickAt: fight.next_tick_at || (Date.now() + (fight.tick_window_ms || 600)),
      status: 'active',
      round: fight.round || 1,
      roundsWon: fight.rounds_won || { p1: 0, p2: 0 },
      lastNarrative: '',
    };

    player.hp = selfState.hp;
    player.prayer = selfState.prayer;
    player.x = 10000;
    combatLog = [`Fight started! ${player.agent_id} vs ${opponentState.agent_id}`];
    showFloatingText('MATCH FOUND', '#d4a017');

    if(worldWs && worldWs.readyState === WebSocket.OPEN) {
      worldWs.send(JSON.stringify({ type: 'spectate', fight_id: fightId }));
    }

    runArenaLoop();
  } catch(e) {
    showFloatingText('Failed to start duel', '#cc3333');
  }
}

// ─── ARENA COMBAT LOOP ───
const PLAYER_ATTACKS = {
  melee: ['godsword_smash','whip_flick','slash','crush','stab'],
  ranged: ['crossbow_bolt','rapid_shot','longrange_shot','knife_throw','dark_bow_spec'],
  magic: ['ice_barrage','fire_blast','blood_barrage','entangle','teleblock','vengeance'],
};
const PLAYER_SPECIALS = {
  melee: ['ags_spec','dds_spec','gmaul_spec','vls_spec','claws_spec','none'],
  ranged: ['dbow_spec','zcb_spec','none'],
  magic: ['staff_spec','sgs_spec','none'],
};
const PLAYER_PRAYERS = {
  melee: ['protect_magic','smite','piety','none'],
  ranged: ['protect_melee','smite','rigour','none'],
  magic: ['protect_ranged','smite','augury','none'],
};
const FOODS = ['eat_shark','karambwan','brew_sip','combo_eat','none'];

function scheduleNextArenaLoop(ms = 800) {
  if(arenaLoopTimer) clearTimeout(arenaLoopTimer);
  arenaLoopTimer = setTimeout(runArenaLoop, ms);
}

async function runArenaLoop() {
  if(!arenaFight || arenaFight.status !== 'active') return;

  // Player auto-action
  const pAttacks = PLAYER_ATTACKS[player.combat_class];
  const pSpecials = PLAYER_SPECIALS[player.combat_class];
  const pPrayers = PLAYER_PRAYERS[player.combat_class];

  const pAttack = pAttacks[Math.floor(Math.random()*pAttacks.length)];
  const pSpecial = Math.random() < 0.3 ? pSpecials[Math.floor(Math.random()*pSpecials.length)] : 'none';
  const pPrayer = pPrayers[Math.floor(Math.random()*pPrayers.length)];
  const pFood = player.hp < 40 ? FOODS[Math.floor(Math.random()*FOODS.length)] : 'none';

  try {
    const actionRes = await apiFetch(API+'/action', {method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({agent_id:player.agent_id,fight_id:arenaFight.fight_id,
        action:pAttack,special:pSpecial||'none',food:pFood,prayer:pPrayer})});
    const actionData = await actionRes.json();

    // If queue fallback produced a bot, this client drives bot turns.
    if(arenaFight.opponent.id.startsWith('QueueBot_')) {
      const botClass = arenaFight.opponent.class;
      const botAttacks = PLAYER_ATTACKS[botClass];
      const botSpecials = PLAYER_SPECIALS[botClass];
      const botPrayers = PLAYER_PRAYERS[botClass];
      const botAttack = botAttacks[Math.floor(Math.random()*botAttacks.length)];
      const botSpecial = Math.random() < 0.3 ? botSpecials[Math.floor(Math.random()*botSpecials.length)] : 'none';
      const botPrayer = botPrayers[Math.floor(Math.random()*botPrayers.length)];
      const botFood = arenaFight.opponent.hp < 40 ? FOODS[Math.floor(Math.random()*FOODS.length)] : 'none';

      const res = await apiFetch(API+'/action', {method:'POST',headers:{'Content-Type':'application/json'},
        body:JSON.stringify({agent_id:arenaFight.opponent.id,fight_id:arenaFight.fight_id,
          action:botAttack,special:botSpecial||'none',food:botFood,prayer:botPrayer})});
      const data = await res.json();
      if(data.fight) {
        const hasResolved = data.result && typeof data.result.tick === 'number';
        const advanced = typeof data.fight.tick === 'number' && arenaFight && data.fight.tick > arenaFight.tick;
        if(hasResolved || advanced) {
          applyFightUpdate(data.fight, data.result || data.fight.last_result || null);
        }
      }
    } else if(actionData.fight) {
      const hasResolved = actionData.result && typeof actionData.result.tick === 'number';
      const advanced = typeof actionData.fight.tick === 'number' && arenaFight && actionData.fight.tick > arenaFight.tick;
      if(hasResolved || advanced) {
        applyFightUpdate(actionData.fight, actionData.result || actionData.fight.last_result || null);
      }
    } else {
      // For real PvP, state arrives via websocket tick_update. Poll fallback:
      const stateRes = await apiFetch(API + '/fight/' + arenaFight.fight_id);
      if(stateRes.ok) {
        const state = await stateRes.json();
        applyFightUpdate(state, state.last_result || null, false);
      }
    }
  } catch(e) {
    combatLog.push('Error: ' + e.message);
  }

  if(arenaFight && arenaFight.status === 'active') {
    scheduleNextArenaLoop(800);
  }
}

function applyFightUpdate(f, tickResult, allowRoundTransition = true) {
  if(!arenaFight || !f) return;

  const isP1 = f.p1.agent_id === player.agent_id;
  const selfState = isP1 ? f.p1 : f.p2;
  const oppState = isP1 ? f.p2 : f.p1;
  const prevTick = arenaFight.tick;

  const prevPlayerHp = player.hp;
  const prevOpHp = arenaFight.opponent.hp;

  player.hp = selfState.hp;
  player.prayer = selfState.prayer;
  arenaFight.opponent.hp = oppState.hp;
  arenaFight.opponent.prayer = oppState.prayer;
  arenaFight.tick = f.tick;
  arenaFight.tickWindowMs = f.tick_window_ms || arenaFight.tickWindowMs || 600;
  arenaFight.nextTickAt = f.next_tick_at || arenaFight.nextTickAt || (Date.now() + (arenaFight.tickWindowMs || 600));
  arenaFight.round = f.round;
  arenaFight.roundsWon = f.rounds_won;
  arenaFight.lastNarrative = tickResult?.narrative || '';

  const hasFreshTick = !!tickResult && typeof tickResult.tick === 'number' && tickResult.tick > prevTick;

  // Spawn hit splats only on fresh tick resolves.
  const pDmg = prevPlayerHp - player.hp;
  const oDmg = prevOpHp - arenaFight.opponent.hp;
  if(hasFreshTick) {
    if(pDmg > 0) { spawnHitsplat(player.x, player.y - 50, pDmg, 'damage'); cam.shake = 5; }
    if(pDmg < 0) spawnHitsplat(player.x, player.y - 50, Math.abs(pDmg), 'heal');
    if(oDmg > 0) spawnHitsplat(arenaFight.opponent.x, arenaFight.opponent.y - 50, oDmg, 'damage');
    if(oDmg < 0) spawnHitsplat(arenaFight.opponent.x, arenaFight.opponent.y - 50, Math.abs(oDmg), 'heal');

    spawnAttackAnimation(player.x, player.y, arenaFight.opponent.x, player.combat_class);
    spawnAttackAnimation(arenaFight.opponent.x, arenaFight.opponent.y, player.x, arenaFight.opponent.class);
  }

  if(hasFreshTick && typeof arenaFight.lastNarrative === 'string' && arenaFight.lastNarrative.length > 0) {
    combatLog.push(`T${tickResult.tick}: ${arenaFight.lastNarrative}`);
  }
  while(combatLog.length > 8) combatLog.shift();

  if(f.status === 'fight_over') {
    arenaFight.status = 'fight_over';
    const won = (isP1 ? f.rounds_won.p1 : f.rounds_won.p2) > (isP1 ? f.rounds_won.p2 : f.rounds_won.p1);
    showFloatingText(won ? 'VICTORY!' : 'DEFEAT!', won ? '#d4a017' : '#cc3333');
    combatLog.push(won ? '🏆 You won the fight!' : '💀 You lost the fight.');
    if(arenaLoopTimer) clearTimeout(arenaLoopTimer);
    setTimeout(() => {
      player.inFight = false;
      arenaFight = null;
      player.hp = player.maxHp;
      player.prayer = player.maxPrayer;
      if(worldReturnPoint) {
        player.x = worldReturnPoint.x;
        player.y = worldReturnPoint.y;
        player.area_id = worldReturnPoint.area_id;
        player.instance_id = worldReturnPoint.instance_id;
        worldReturnPoint = null;
      }
      if(worldWs && worldWs.readyState === WebSocket.OPEN) {
        worldWs.send(JSON.stringify({
          type:'world_subscribe',
          area_id: player.area_id || DEFAULT_AREA_ID,
          instance_id: player.instance_id || null,
        }));
        fetchResourceNodes().catch(()=>{});
        sendWorldUpdate(true);
      }
    }, 3500);
    return;
  }

  if(f.status === 'round_over' && allowRoundTransition) {
    combatLog.push(`--- Round ${f.round + 1} ---`);
    apiFetch(API+'/next-round', {method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({fight_id:arenaFight.fight_id})}).catch(()=>{});
  }
}

function spawnAttackAnimation(fromX, fromY, toX, combatClass) {
  const color = combatClass==='melee'?'#cc3333':combatClass==='ranged'?'#33cc33':'#3388cc';
  arenaAnimations.push({
    x: fromX, y: fromY - 25,
    tx: toX, ty: fromY - 25,
    progress: 0, speed: combatClass==='magic'?0.04:combatClass==='ranged'?0.06:0.1,
    color, type: combatClass,
  });
}

function showFloatingText(text, color) {
  spawnParticle(player.x, player.y - 80, 'text', text, color);
}

function getNearestResourceNode(maxDist = 90) {
  let best = null;
  let bestDist = Infinity;
  resourceNodes.forEach(node => {
    if(!isSameShard(node.area_id, node.instance_id)) return;
    const depleted = node.depleted_until && node.depleted_until > Date.now();
    if(depleted) return;
    const d = Math.abs(node.x - player.x);
    if(d < maxDist && d < bestDist) {
      best = node;
      bestDist = d;
    }
  });
  return best;
}

async function toggleResourceInteraction(node) {
  if(!player.agent_id) return;
  try {
    if(skillActionNodeId === node.node_id) {
      await apiFetch('/api/v1/world/interact', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({agent_id:player.agent_id,node_id:node.node_id,action:'stop'})
      });
      skillActionNodeId = null;
      showFloatingText('Stopped training', '#999');
      return;
    }

    const res = await apiFetch('/api/v1/world/interact', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({agent_id:player.agent_id,node_id:node.node_id,action:'start'})
    });
    const data = await res.json();
    if(res.ok) {
      skillActionNodeId = node.node_id;
      showFloatingText(`${formatSkillName(node.skill)}...`, '#66d4ff');
      markTutorialGoal('interact_node');
    } else {
      showFloatingText(data.error || 'Cannot train here', '#cc3333');
    }
  } catch {
    showFloatingText('Interaction failed', '#cc3333');
  }
}

function getNearbyPortalObject(maxDist = 110) {
  let best = null;
  let bestDist = Infinity;
  for(const obj of worldObjects) {
    const areaId = obj.area_id || DEFAULT_AREA_ID;
    if(areaId !== (player.area_id || DEFAULT_AREA_ID)) continue;
    if(!obj.portal_id) continue;
    const centerX = obj.x + obj.w / 2;
    const d = Math.abs(centerX - player.x);
    if(d < maxDist && d < bestDist) {
      best = obj;
      bestDist = d;
    }
  }
  return best;
}

async function useWorldPortal(portalObj) {
  if(!player.agent_id || !portalObj?.portal_id) return;
  try {
    const res = await apiFetch('/api/v1/world/portal/use', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        agent_id: player.agent_id,
        portal_id: portalObj.portal_id,
        scope: portalObj.portal_scope || 'shared',
        arena: portalObj.portal_kind === 'duel_queue' ? 'duel_arena' : undefined,
      }),
    });
    const data = await res.json();
    if(!res.ok) {
      showFloatingText(data.error || 'Portal failed', '#cc3333');
      return;
    }
    if(data.status === 'portal_queued') {
      queuedForDuel = true;
      showFloatingText(`Queued (${data.queue_size})`, '#d4a017');
      openDuelQueueOverlay();
      return;
    }
    if(data.world) {
      setWorldStateFromServer(data.world);
      await fetchResourceNodes();
      await loadQuestJournal();
      sendWorldUpdate(true);
      showZoneLabel(getZone(player.x)?.name || 'New Area');
      showFloatingText(`Entered ${data.area?.name || 'new area'}`, '#66d4ff');
      markTutorialGoal('use_portal');
    }
  } catch {
    showFloatingText('Portal failed', '#cc3333');
  }
}

function isNearDuelPortal() {
  const portal = getNearbyPortalObject(120);
  return !!(portal && portal.portal_kind === 'duel_queue');
}

// ─── UPDATE ───
function update() {
  tick++;
  if((tick % 10) === 0) {
    updateTutorialTracker();
  }

  if(registrationOpen) {
    const closeKeys = ['q', 'b', 'm', 'k', 'i', 'j', 'n', 't', 'g'];
    for(const key of closeKeys) {
      if(keys[key]) {
        keys[key] = false;
        combatOverlay.style.display = 'none';
        registrationOpen = false;
      }
    }
  }

  if(dialogueState && dialogueState.mode === 'tree') {
    const digitChoices = ['1','2','3','4'];
    for(const digit of digitChoices) {
      if(keys[digit]) {
        keys[digit] = false;
        const idx = Number(digit) - 1;
        const choice = dialogueState.node?.choices?.[idx];
        if(choice) {
          window.chooseDialogueChoice(choice.choice_id);
        }
      }
    }
  }

  // Player movement
  if(!dialogueState && !registrationOpen) {
    const speed = keys['shift'] ? 4 : 2;
    if(keys['a'] || keys['arrowleft']) { player.vx = -speed; player.facing = -1; }
    else if(keys['d'] || keys['arrowright']) { player.vx = speed; player.facing = 1; }
    else { player.vx *= 0.8; }

    if((keys[' '] || keys['w'] || keys['arrowup']) && player.onGround) {
      player.vy = -10;
      player.onGround = false;
    }

    // Interact
    if(keys['e']) {
      keys['e'] = false;
      if(dialogueState) { advanceDialogue(); }
      else {
        const nearbyNode = getNearestResourceNode();
        const nearbyPortal = getNearbyPortalObject();
        if(nearbyNode && !player.inFight) {
          toggleResourceInteraction(nearbyNode);
        } else if(nearbyPortal && !player.inFight) {
          if(nearbyPortal.portal_kind === 'duel_queue') openDuelQueueOverlay();
          else useWorldPortal(nearbyPortal);
        } else {
          const nearNpc = npcs.find(n =>
            (n.area_id || DEFAULT_AREA_ID) === (player.area_id || DEFAULT_AREA_ID) &&
            Math.abs(n.x - player.x) < 60
          );
          if(nearNpc) openDialogue(nearNpc);
        }
      }
    }
    if(keys['q']) {
      keys['q'] = false;
      if(dialogueState) closeDialogue();
      if(registrationOpen) { combatOverlay.style.display = 'none'; registrationOpen = false; }
      if(skillActionNodeId && player.agent_id) {
        apiFetch('/api/v1/world/interact', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body:JSON.stringify({agent_id:player.agent_id,node_id:skillActionNodeId,action:'stop'})
        }).catch(()=>{});
        skillActionNodeId = null;
      }
    }
    if(keys['b']) {
      keys['b'] = false;
      if(registrationOpen) {
        combatOverlay.style.display = 'none';
        registrationOpen = false;
      } else {
        openSpellbookOverlay();
      }
    }
    if(keys['k']) {
      keys['k'] = false;
      if(registrationOpen) {
        combatOverlay.style.display = 'none';
        registrationOpen = false;
      } else {
        openSkillsOverlay();
      }
    }
    if(keys['m']) {
      keys['m'] = false;
      if(registrationOpen) {
        combatOverlay.style.display = 'none';
        registrationOpen = false;
      } else {
        openAtlasOverlay();
      }
    }
    if(keys['i']) {
      keys['i'] = false;
      if(registrationOpen) {
        combatOverlay.style.display = 'none';
        registrationOpen = false;
      } else {
        openInventoryOverlay();
      }
    }
    if(keys['j']) {
      keys['j'] = false;
      if(registrationOpen) {
        combatOverlay.style.display = 'none';
        registrationOpen = false;
      } else {
        openQuestLogOverlay();
      }
    }
    if(keys['n']) {
      keys['n'] = false;
      if(registrationOpen) {
        combatOverlay.style.display = 'none';
        registrationOpen = false;
      } else {
        openBankOverlay();
      }
    }
    if(keys['t']) {
      keys['t'] = false;
      if(registrationOpen) {
        combatOverlay.style.display = 'none';
        registrationOpen = false;
      } else {
        openTradeOverlay();
      }
    }
    if(keys['g']) {
      keys['g'] = false;
      if(registrationOpen) {
        combatOverlay.style.display = 'none';
        registrationOpen = false;
      } else {
        openGrandExchangeOverlay();
      }
    }
    if(keys['p']) {
      keys['p'] = false;
      if(registrationOpen) {
        closeCombatOverlay();
      } else {
        openProfilePanel();
      }
    }
    if(keys['h']) {
      keys['h'] = false;
      if(registrationOpen) {
        closeCombatOverlay();
      } else {
        window.openWorldHighscores('pvp');
      }
    }
    if(keys['c']) {
      keys['c'] = false;
      if(registrationOpen) {
        closeCombatOverlay();
      } else {
        window.openCharacterPanel();
      }
    }
    if(keys['y']) {
      keys['y'] = false;
      if(registrationOpen) {
        closeCombatOverlay();
      } else {
        window.openNearbyChallengeOverlay();
      }
    }
    if(keys['l']) {
      keys['l'] = false;
      logoutToLanding();
    }
    if(keys['o']) {
      keys['o'] = false;
      window.location.href = '/agent-console.html';
    }
    if(keys['f']) {
      keys['f'] = false;
      const nearArenaMaster = npcs.find(n =>
        n.isArenaMaster &&
        (n.area_id || DEFAULT_AREA_ID) === (player.area_id || DEFAULT_AREA_ID) &&
        Math.abs(n.x - player.x) < 100
      );
      if(nearArenaMaster) registerForArena();
    }
  }

  // Physics
  player.x += player.vx;
  player.vy += GRAVITY;
  player.y += player.vy;
  if(player.y >= GROUND_Y) { player.y = GROUND_Y; player.vy = 0; player.onGround = true; }
  const areaWidth = getAreaWidth();
  player.x = Math.max(20, Math.min(areaWidth - 20, player.x));

  // Walk animation
  if(Math.abs(player.vx) > 0.5) { player.walkTimer += Math.abs(player.vx) * 0.15; }

  // Camera
  const targetCamX = player.x - W/2;
  const targetCamY = Math.min(0, player.y - H/2 + 100);
  cam.x += (targetCamX - cam.x) * 0.08;
  cam.y += (targetCamY - cam.y) * 0.08;
  cam.x = Math.max(0, Math.min(areaWidth - W, cam.x));

  // Camera shake
  if(cam.shake > 0) {
    cam.x += (Math.random()-0.5) * cam.shake * 2;
    cam.y += (Math.random()-0.5) * cam.shake * 2;
    cam.shake *= 0.85;
    if(cam.shake < 0.3) cam.shake = 0;
  }

  // Zone detection
  currentZone = getZone(player.x);
  showZoneLabel(currentZone.name);
  sendWorldUpdate();

  // Particles
  particles = particles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.05;
    p.life -= 0.02;
    return p.life > 0;
  });

  // Arena animations
  arenaAnimations = arenaAnimations.filter(a => {
    a.progress += a.speed;
    return a.progress < 1;
  });

  // Clouds
  clouds.forEach(c => { c.x += c.speed; if(c.x > WORLD_W + 200) c.x = -200; });
}

// ─── RENDER ───
function render() {
  ctx.clearRect(0, 0, W, H);

  // Sky gradient based on zone
  const zone = currentZone;
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, zone.sky);
  grad.addColorStop(1, zone.name === 'Wilderness' || zone.name === 'Wilderness Border' ? '#1a0505' : '#0a0a15');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  const areaId = player.area_id || DEFAULT_AREA_ID;
  const bgAssetId = backgroundAssetByArea[areaId];
  if(bgAssetId && generatedAssets.has(bgAssetId)) {
    const bg = generatedAssets.get(bgAssetId);
    const parallaxOffset = -(cam.x * 0.08) % W;
    ctx.globalAlpha = 0.42;
    for(let i = -1; i <= 1; i++) {
      ctx.drawImage(bg, parallaxOffset + i * W, 0, W, H);
    }
    ctx.globalAlpha = 1;
  }

  // Stars
  ctx.fillStyle = '#fff';
  stars.forEach(s => {
    const sx = s.x - cam.x * 0.1;
    const twinkle = 0.3 + Math.sin(tick * 0.02 + s.b * 100) * 0.7;
    ctx.globalAlpha = twinkle * 0.6;
    ctx.fillRect(sx % W, s.y, s.s, s.s);
  });
  ctx.globalAlpha = 1;

  // Clouds
  ctx.fillStyle = 'rgba(40,40,60,0.3)';
  clouds.forEach(c => {
    const cx = c.x - cam.x * 0.3;
    ctx.beginPath();
    ctx.ellipse(cx, c.y, c.w/2, 15, 0, 0, Math.PI*2);
    ctx.fill();
  });

  // Mountains (parallax)
  ctx.fillStyle = '#1a1a2a';
  for(let i = 0; i < W + 200; i += 200) {
    const mx = i - (cam.x * 0.2) % 200;
    const mh = 80 + Math.sin(i * 0.01 + 1) * 40;
    ctx.beginPath();
    ctx.moveTo(mx, GROUND_Y - cam.y);
    ctx.lineTo(mx + 100, GROUND_Y - mh - cam.y);
    ctx.lineTo(mx + 200, GROUND_Y - cam.y);
    ctx.fill();
  }

  // Hills (parallax)
  ctx.fillStyle = '#151525';
  for(let i = 0; i < W + 300; i += 300) {
    const hx = i - (cam.x * 0.4) % 300;
    ctx.beginPath();
    ctx.arc(hx + 150, GROUND_Y - cam.y + 20, 160, Math.PI, 0);
    ctx.fill();
  }

  // Ground — per zone coloring
  const zones = getAreaZones();
  for(const z of zones) {
    const gx = z.x - cam.x;
    const gy = GROUND_Y - cam.y;
    if(gx + z.w < 0 || gx > W) continue;
    // Ground top
    ctx.fillStyle = z.groundTop;
    ctx.fillRect(gx, gy, z.w, 6);
    // Ground body
    ctx.fillStyle = z.ground;
    ctx.fillRect(gx, gy + 6, z.w, H - gy);
  }

  // Zone transition effects
  if(currentZone.name === 'Wilderness' || currentZone.name === 'Wilderness Border') {
    // Red vignette
    const vg = ctx.createRadialGradient(W/2, H/2, H*0.3, W/2, H/2, H);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(100,0,0,0.3)');
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, W, H);
  }

  // World objects
  worldObjects.forEach(o => {
    const areaId = o.area_id || DEFAULT_AREA_ID;
    if(areaId !== (player.area_id || DEFAULT_AREA_ID)) return;
    if(o.x + o.w + 100 > cam.x && o.x - 100 < cam.x + W) drawWorldObject(o);
  });

  // Resource nodes
  resourceNodes.forEach(node => {
    if(Math.abs(node.x - cam.x - W / 2) > W) return;
    const nx = node.x - cam.x;
    const ny = GROUND_Y - cam.y - 10;
    const depleted = node.depleted_until && node.depleted_until > Date.now();
    const isActive = skillActionNodeId === node.node_id;
    const visual = getSkillVisual(node.skill);
    const skillColor = visual.color;

    ctx.fillStyle = depleted ? '#444' : skillColor;
    ctx.beginPath();
    ctx.arc(nx, ny, depleted ? 8 : 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = isActive ? '#d4a017' : '#222';
    ctx.lineWidth = isActive ? 2 : 1;
    ctx.stroke();
    if(!depleted) {
      ctx.fillStyle = 'rgba(10,10,15,0.85)';
      ctx.font = '8px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(visual.icon, nx, ny + 3);
    }

    const near = Math.abs(node.x - player.x) < 85 && !player.inFight;
    if(near) {
      ctx.fillStyle = '#d4a017';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      const suffix = depleted ? ' (depleted)' : '';
      ctx.fillText(`${formatSkillName(node.skill)} ${node.level_required}+${suffix}`, nx, ny - 16);
      if(!depleted) {
        ctx.fillStyle = '#999';
        ctx.fillText('[E] Train', nx, ny - 27);
      }
    }
  });

  // NPCs
  npcs.forEach(npc => {
    const areaId = npc.area_id || DEFAULT_AREA_ID;
    if(areaId !== (player.area_id || DEFAULT_AREA_ID)) return;
    if(Math.abs(npc.x - cam.x - W/2) < W) drawNPC(npc);
  });

  // Portal hint
  const nearbyPortal = getNearbyPortalObject(120);
  if(nearbyPortal && !player.inFight) {
    ctx.fillStyle = '#d4a017';
    ctx.font = '11px Courier New';
    ctx.textAlign = 'center';
    const centerX = nearbyPortal.x + nearbyPortal.w / 2;
    const label = nearbyPortal.portal_kind === 'duel_queue' ? '[E] Duel Queue' : `[E] ${nearbyPortal.label || 'Use Portal'}`;
    ctx.fillText(label, centerX - cam.x, GROUND_Y - cam.y - 170);
  }

  // Other connected agents in the open world
  worldAgents.forEach((agent) => {
    if(Math.abs(agent.x - cam.x - W/2) > W) return;
    const equipment = getEquipmentForClass(agent.combat_class);
    drawCharacter(agent.x, agent.y, player.x > agent.x ? 1 : -1, tick * 0.08, {
      body: agent.combat_class === 'melee' ? '#aa3333' : agent.combat_class === 'ranged' ? '#339944' : '#3366aa',
      hat: agent.combat_class === 'melee' ? '#7a2222' : agent.combat_class === 'ranged' ? '#226622' : '#224477',
      skin: '#c8a882',
      legs: '#2a2a3a',
      arms: agent.combat_class === 'melee' ? '#993333' : agent.combat_class === 'ranged' ? '#2f8b3f' : '#335999',
    }, 24, 40, equipment, agent.avatar_id || DEFAULT_PLAYER_SPRITES[agent.combat_class] || `player_${agent.combat_class}`);

    drawText(agent.agent_id, agent.x, agent.y - 56, '#66d4ff', 9);
  });

  // Arena opponent
  if(arenaFight && arenaFight.opponent) {
    const op = arenaFight.opponent;
    const opEquip = getEquipmentForClass(op.class);
    drawCharacter(op.x, op.y, op.facing, tick*0.1, {
      body: op.class==='melee'?'#aa3333':op.class==='ranged'?'#33aa33':'#3366aa',
      hat: op.class==='melee'?'#882222':op.class==='ranged'?'#228822':'#224488',
      skin:'#b89a72', legs:'#2a2a3a', arms: op.class==='melee'?'#993333':op.class==='ranged'?'#339933':'#335599'
    }, 24, 40, opEquip, `player_${op.class}`);

    // Opponent HP bar
    const ohx = op.x - cam.x - 20;
    const ohy = op.y - cam.y - 60;
    ctx.fillStyle = '#333';
    ctx.fillRect(ohx, ohy, 40, 5);
    ctx.fillStyle = op.hp > 30 ? '#33cc33' : '#cc3333';
    ctx.fillRect(ohx, ohy, 40 * (op.hp/op.maxHp), 5);
    drawText(op.id, op.x, op.y - 70, '#cc5555', 10);
  }

  // Arena attack animations
  arenaAnimations.forEach(a => {
    const cx = a.x + (a.tx - a.x) * a.progress;
    const cy = a.y + Math.sin(a.progress * Math.PI) * -30;
    ctx.fillStyle = a.color;
    ctx.globalAlpha = 1 - a.progress;
    if(a.type === 'magic') {
      ctx.beginPath();
      ctx.arc(cx - cam.x, cy - cam.y, 8 - a.progress*6, 0, Math.PI*2);
      ctx.fill();
      // Trail
      for(let i = 0; i < 3; i++) {
        ctx.globalAlpha = (1 - a.progress) * 0.3;
        ctx.beginPath();
        ctx.arc(cx - cam.x - (a.tx-a.x)*0.05*i, cy - cam.y + i*2, 4, 0, Math.PI*2);
        ctx.fill();
      }
    } else if(a.type === 'ranged') {
      ctx.fillRect(cx - cam.x - 6, cy - cam.y - 1, 12, 2);
    } else {
      // Melee slash arc
      ctx.strokeStyle = a.color;
      ctx.lineWidth = 3;
      ctx.globalAlpha = 1 - a.progress;
      ctx.beginPath();
      ctx.arc(cx - cam.x, cy - cam.y, 15, -Math.PI*a.progress, Math.PI*(1-a.progress));
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  });

  // Player
  const pColors = {
    body: player.combat_class==='melee'?'#8a3333':player.combat_class==='ranged'?'#33883a':'#335588',
    hat: player.combat_class==='melee'?'#6a2222':player.combat_class==='ranged'?'#226622':'#223366',
    skin: '#c8a882',
    legs: '#2a2a4a',
    arms: player.combat_class==='melee'?'#7a3333':player.combat_class==='ranged'?'#33773a':'#334477',
  };
  drawCharacter(
    player.x,
    player.y,
    player.facing,
    player.walkTimer,
    pColors,
    24,
    40,
    player.equipment,
    player.avatar_id || DEFAULT_PLAYER_SPRITES[player.combat_class] || `player_${player.combat_class}`
  );

  // Player name
  if(player.agent_id) {
    drawText(player.agent_id, player.x, player.y - 55, '#33cc33', 10);
  }

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = Math.max(0, p.life);
    if(p.type === 'hitsplat') {
      // RuneScape-style hitsplat
      const px = p.x - cam.x;
      const py = p.y - cam.y;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.ellipse(px, py, 16, 12, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(p.text, px, py + 4);
    } else if(p.type === 'text') {
      ctx.fillStyle = p.color;
      ctx.font = 'bold 16px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(p.text, p.x - cam.x, p.y - cam.y);
    } else {
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - cam.x - p.size/2, p.y - cam.y - p.size/2, p.size, p.size);
    }
    ctx.globalAlpha = 1;
  });

  // ─── HUD ───
  renderHUD();
  renderMinimap();
  renderCombatLog();
  renderQuestTracker();
}

function renderHUD() {
  hpCtx.clearRect(0, 0, 200, 80);

  // HP bar
  hpCtx.fillStyle = 'rgba(0,0,0,0.7)';
  hpCtx.fillRect(0, 0, 200, 80);
  hpCtx.strokeStyle = '#d4a017';
  hpCtx.lineWidth = 1;
  hpCtx.strokeRect(0, 0, 200, 80);

  // HP
  hpCtx.fillStyle = '#888';
  hpCtx.font = '10px Courier New';
  hpCtx.textAlign = 'left';
  hpCtx.fillText('Hitpoints', 10, 16);
  hpCtx.fillStyle = '#222';
  hpCtx.fillRect(10, 20, 180, 14);
  const hpPct = player.hp / player.maxHp;
  hpCtx.fillStyle = hpPct > 0.3 ? '#33cc33' : '#cc3333';
  hpCtx.fillRect(10, 20, 180 * hpPct, 14);
  hpCtx.fillStyle = '#fff';
  hpCtx.font = 'bold 10px Courier New';
  hpCtx.textAlign = 'center';
  hpCtx.fillText(`${player.hp} / ${player.maxHp}`, 100, 32);

  // Prayer
  hpCtx.fillStyle = '#888';
  hpCtx.font = '10px Courier New';
  hpCtx.textAlign = 'left';
  hpCtx.fillText('Prayer', 10, 50);
  hpCtx.fillStyle = '#222';
  hpCtx.fillRect(10, 54, 180, 14);
  const prayPct = player.prayer / player.maxPrayer;
  hpCtx.fillStyle = '#3388cc';
  hpCtx.fillRect(10, 54, 180 * prayPct, 14);
  hpCtx.fillStyle = '#fff';
  hpCtx.font = 'bold 10px Courier New';
  hpCtx.textAlign = 'center';
  hpCtx.fillText(`${player.prayer} / ${player.maxPrayer}`, 100, 66);

  hpCtx.fillStyle = '#7e91a7';
  hpCtx.font = '9px Courier New';
  hpCtx.textAlign = 'left';
  hpCtx.fillText('I Inv  J Quests  N Bank  T Trade  G GE', 10, 76);
}

function renderMinimap() {
  minimapCtx.clearRect(0, 0, 180, 60);
  minimapCtx.fillStyle = 'rgba(0,0,0,0.8)';
  minimapCtx.fillRect(0, 0, 180, 60);

  const areaWidth = getAreaWidth();
  const scale = 180 / areaWidth;
  const zones = getAreaZones();

  // Zone colors on minimap
  zones.forEach(z => {
    minimapCtx.fillStyle = z.ground;
    minimapCtx.fillRect(z.x * scale, 40, z.w * scale, 20);
  });

  // Zone labels
  minimapCtx.fillStyle = '#888';
  minimapCtx.font = '7px Courier New';
  minimapCtx.textAlign = 'center';
  zones.forEach(z => {
    minimapCtx.fillText(z.name.split(' ')[0], (z.x + z.w/2) * scale, 12);
  });

  // Portals
  worldObjects.forEach((obj) => {
    const areaId = obj.area_id || DEFAULT_AREA_ID;
    if(areaId !== (player.area_id || DEFAULT_AREA_ID)) return;
    if(!obj.portal_id) return;
    minimapCtx.fillStyle = obj.portal_kind === 'duel_queue' ? '#d4a017' : '#7fa1ff';
    minimapCtx.fillRect((obj.x + obj.w / 2) * scale - 1, 28, 3, 6);
  });

  // Resource nodes
  resourceNodes.forEach((node) => {
    if(!isSameShard(node.area_id, node.instance_id)) return;
    const visual = getSkillVisual(node.skill);
    minimapCtx.fillStyle = visual.color;
    minimapCtx.fillRect(node.x * scale - 1, 54, 2, 2);
  });

  // NPCs
  npcs.forEach(n => {
    if((n.area_id || DEFAULT_AREA_ID) !== (player.area_id || DEFAULT_AREA_ID)) return;
    minimapCtx.fillStyle = '#d4a017';
    minimapCtx.fillRect(n.x * scale - 1, 35, 2, 4);
  });

  // Connected agents
  worldAgents.forEach(agent => {
    minimapCtx.fillStyle = '#66d4ff';
    minimapCtx.fillRect(agent.x * scale - 1, 36, 2, 4);
  });

  // Player
  minimapCtx.fillStyle = '#33ff33';
  minimapCtx.fillRect(player.x * scale - 2, 32, 4, 6);

  // Viewport
  minimapCtx.strokeStyle = '#d4a017';
  minimapCtx.lineWidth = 1;
  minimapCtx.strokeRect(cam.x * scale, 20, W * scale, 30);
}

function renderCombatLog() {
  if(!player.inFight || combatLog.length === 0) return;

  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(10, H - 200, 380, 180);
  ctx.strokeStyle = '#d4a017';
  ctx.lineWidth = 1;
  ctx.strokeRect(10, H - 200, 380, 180);

  ctx.fillStyle = '#d4a017';
  ctx.font = 'bold 11px Courier New';
  ctx.textAlign = 'left';
  ctx.fillText('⚔ Combat Log', 20, H - 183);

  ctx.font = '10px Courier New';
  const visible = combatLog.slice(-7);
  visible.forEach((line, i) => {
    ctx.fillStyle = line.includes('VICTORY') || line.includes('won') ? '#d4a017'
                  : line.includes('DEFEAT') || line.includes('lost') ? '#cc3333'
                  : line.startsWith('---') ? '#888' : '#ccc';
    ctx.fillText(line.slice(0, 55), 20, H - 165 + i * 18);
  });

  // Round score
  if(arenaFight) {
    const youScore = arenaFight.playerSlot === 'p1' ? arenaFight.roundsWon.p1 : arenaFight.roundsWon.p2;
    const oppScore = arenaFight.playerSlot === 'p1' ? arenaFight.roundsWon.p2 : arenaFight.roundsWon.p1;
    const tickCountdown = Math.max(0, (arenaFight.nextTickAt || 0) - Date.now());
    ctx.fillStyle = '#d4a017';
    ctx.font = 'bold 12px Courier New';
    ctx.textAlign = 'right';
    ctx.fillText(`Round ${arenaFight.round} | You ${youScore} - ${oppScore} Opponent`, 380, H - 183);
    ctx.fillText(`Tick ${arenaFight.tick} • Next ${tickCountdown}ms`, 380, H - 168);
  }
}

function renderQuestTracker() {
  if(!Array.isArray(questLog) || questLog.length === 0) return;
  const active = questLog.filter((quest) => quest.status === 'in_progress').slice(0, 3);
  const turnIns = questLog.filter((quest) => quest.status === 'completed' && !quest.reward_claimed).slice(0, 2);
  if(active.length === 0 && turnIns.length === 0) return;

  const panelX = 20;
  const panelY = 120;
  const panelW = 340;
  const lineH = 16;
  const rows = 1 + active.length + turnIns.length;
  const panelH = 18 + rows * lineH + 10;

  ctx.fillStyle = 'rgba(0,0,0,0.72)';
  ctx.fillRect(panelX, panelY, panelW, panelH);
  ctx.strokeStyle = '#44637d';
  ctx.lineWidth = 1;
  ctx.strokeRect(panelX, panelY, panelW, panelH);

  ctx.fillStyle = '#66d4ff';
  ctx.font = 'bold 11px Courier New';
  ctx.textAlign = 'left';
  ctx.fillText('Quest Tracker', panelX + 10, panelY + 13);

  let row = 0;
  for(const quest of active) {
    const objective = quest.objectives.find((entry) => !entry.complete) || quest.objectives[quest.active_objective_index] || quest.objectives[0];
    const text = objective
      ? `${quest.name}: ${objective.description} (${Math.min(objective.current, objective.target)}/${objective.target})`
      : `${quest.name}: progressing`;
    ctx.fillStyle = '#c7d4e8';
    ctx.font = '10px Courier New';
    ctx.fillText(text.slice(0, 52), panelX + 10, panelY + 30 + row * lineH);
    row += 1;
  }
  for(const quest of turnIns) {
    ctx.fillStyle = '#d4a017';
    ctx.font = '10px Courier New';
    ctx.fillText(`Turn in: ${quest.name} (${quest.turn_in_npc_id})`, panelX + 10, panelY + 30 + row * lineH);
    row += 1;
  }
}

// ─── GAME LOOP ───
function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

window.render_game_to_text = function renderGameToText() {
  const visibleAgents = [];
  worldAgents.forEach((agent) => {
    visibleAgents.push({
      id: agent.agent_id,
      class: agent.combat_class,
      avatar_id: agent.avatar_id || null,
      x: agent.x,
      y: agent.y,
      zone: agent.zone,
    });
  });

  const visibleNodes = [];
  resourceNodes.forEach((node) => {
    if(Math.abs(node.x - player.x) < 800) {
      visibleNodes.push({
        id: node.node_id,
        type: node.type,
        skill: node.skill,
        level_required: node.level_required,
        depleted: !!(node.depleted_until && node.depleted_until > Date.now()),
      });
    }
  });

  const visiblePortals = [];
  worldObjects.forEach((obj) => {
    if(!obj.portal_id) return;
    const areaId = obj.area_id || DEFAULT_AREA_ID;
    if(areaId !== (player.area_id || DEFAULT_AREA_ID)) return;
    if(Math.abs((obj.x + obj.w / 2) - player.x) > 1400) return;
    visiblePortals.push({
      portal_id: obj.portal_id,
      label: obj.label || obj.portal_id,
      kind: obj.portal_kind || 'travel',
      x: Math.round(obj.x + obj.w / 2),
    });
  });

  const skills = {};
  SKILL_DISPLAY_ORDER.forEach((skill) => {
    const state = player.skills?.[skill] || { level: 1, xp: 0 };
    skills[skill] = { level: state.level, xp: state.xp };
  });

  const payload = {
    coordinate_system: 'origin top-left, +x right, +y down',
    mode: player.inFight ? 'duel_arena' : 'open_world',
    player: {
      id: player.agent_id,
      class: player.combat_class,
      avatar_id: player.avatar_id || null,
      x: Math.round(player.x),
      y: Math.round(player.y),
      hp: player.hp,
      prayer: player.prayer,
      zone: currentZone?.name || null,
      area_id: player.area_id || DEFAULT_AREA_ID,
      instance_id: player.instance_id || null,
      registered: player.registered,
      queued_for_duel: queuedForDuel,
      active_skill_node: skillActionNodeId,
    },
    duel: arenaFight ? {
      fight_id: arenaFight.fight_id,
      round: arenaFight.round,
      tick: arenaFight.tick,
      score: arenaFight.roundsWon,
      opponent: {
        id: arenaFight.opponent.id,
        class: arenaFight.opponent.class,
        hp: arenaFight.opponent.hp,
        prayer: arenaFight.opponent.prayer,
      },
      recent_log: combatLog.slice(-4),
    } : null,
    open_world_agents: visibleAgents,
    resource_nodes: visibleNodes,
    visible_portals: visiblePortals,
    skills,
    quests: (questLog || []).map((quest) => ({
      quest_id: quest.quest_id,
      status: quest.status,
      reward_claimed: quest.reward_claimed,
      active_objective_index: quest.active_objective_index,
    })),
  };

  return JSON.stringify(payload);
};

window.advanceTime = (ms = 16) => {
  const frameMs = 1000 / 60;
  const steps = Math.max(1, Math.round(ms / frameMs));
  for(let i = 0; i < steps; i++) {
    update();
  }
  render();
};

async function bootstrapFromStoredSession() {
  const stored = loadStoredAuth();
  if(!stored?.session_token) return false;

  player.session_token = stored.session_token;
  player.wallet_address = stored.wallet_address || null;
  player.account_id = stored.account_id || null;
  player.agent_id = stored.character_id || null;
  player.actor_type = stored.actor_type || 'human';
  player.character_name = stored.character_name || null;
  player.mode = stored.mode || 'f2p_2007';
  if(stored.combat_class) {
    player.combat_class = stored.combat_class;
  }
  if(typeof stored.avatar_id === 'string' && stored.avatar_id.length > 0) {
    player.avatar_id = stored.avatar_id;
  }

  try {
    const meRes = await apiFetch('/api/v1/character/me');
    if(meRes.ok) {
      const meData = await meRes.json();
      if(meData?.selected_character?.combat_class) {
        player.combat_class = meData.selected_character.combat_class;
      }
      if(meData?.selected_character?.character_id) {
        player.agent_id = meData.selected_character.character_id;
      }
      if(meData?.selected_character?.name) {
        player.character_name = meData.selected_character.name;
      }
      if(meData?.selected_character?.mode) {
        player.mode = meData.selected_character.mode;
      }
      if(meData?.actor_type) {
        player.actor_type = meData.actor_type;
      }
    }

    await loadCharacterState();
    if(!player.agent_id) {
      clearStoredAuth();
      return false;
    }

    const registerRes = await apiFetch('/api/v1/arena/register/self', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        combat_class: player.combat_class,
        avatar_id: player.avatar_id || DEFAULT_PLAYER_SPRITES[player.combat_class] || `player_${player.combat_class}`,
        prayer_book: 'normal',
      }),
    });
    const registerData = await registerRes.json().catch(() => ({}));
    if(!registerRes.ok || registerData.status !== 'registered') {
      clearStoredAuth();
      return false;
    }

    player.registered = true;
    player.character_name = registerData.character?.name || player.character_name;
    player.mode = registerData.character?.mode || player.mode;
    player.actor_type = registerData.account_type || player.actor_type;
    player.equipment = getEquipmentForClass(player.combat_class);
    hydrateTutorialState(player.agent_id);
    updateTutorialTracker();
    saveStoredAuth();
    connectWorldSocket();
    sendWorldUpdate(true);
    await fetchResourceNodes();
    await loadQuestJournal();
    return true;
  } catch {
    clearStoredAuth();
    return false;
  }
}

Promise.resolve()
  .then(() => wirePersistentMenu())
  .then(() => loadGeneratedAssets())
  .then(() => bootstrapFromStoredSession())
  .finally(() => {
    fetchResourceNodes();
    updateTutorialTracker();
    gameLoop();
  });

// ─── PREVENT SCROLL ───
addEventListener('keydown', e => { if([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Tab'].includes(e.key)) e.preventDefault(); });
</script>
</body>
</html>
